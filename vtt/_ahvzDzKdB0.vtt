WEBVTT
Kind: captions
Language: en

00:00:39.160 --> 00:00:41.190
Most of the time I do not read my talks.

00:00:41.190 --> 00:00:43.160
I plan the main points and then speak off
the top

00:00:43.160 --> 00:00:48.040
of my head, but for this talk I need to stick
to a text and for good cause.

00:00:48.040 --> 00:00:51.730
Please bear with me.

00:00:51.730 --> 00:00:54.800
I think you know what a man is.

00:00:54.800 --> 00:00:57.489
A woman is more or less like a man, but not
of the same

00:00:57.489 --> 00:01:00.370
sex.

00:01:00.370 --> 00:01:05.010
This may seem like a strange thing for me
to start with, but soon you will see why.

00:01:05.010 --> 00:01:11.369
Next, I shall say that a person is a woman
or a man- young or old.

00:01:11.369 --> 00:01:15.690
And to keep things
short, when I say 'he' I mean 'he or she,'

00:01:15.690 --> 00:01:17.680
and when I say 'his' I mean 'his or her.'

00:01:17.680 --> 00:01:35.060
A machine is a thing that can do a task with
no help, or not much help, from a person.

00:01:35.060 --> 00:01:40.039
As a rule, we can speak of two or more of
a thing if we add an 's' or 'z' sound to the

00:01:40.039 --> 00:01:49.960
end
of a word that names it.

00:01:49.960 --> 00:01:56.770
These are names of persons: Alan Turing, Alonzo
Church, Charles Kay Ogden, Christopher

00:01:56.770 --> 00:02:04.200
Alexander, Eric Raymond, Fred Brooks, John
Horton Conway, James Gosling, Bill Joy, and

00:02:04.200 --> 00:02:13.560
Dick Gabriel.

00:02:13.560 --> 00:02:16.330
The word 'other' means 'not the same.'

00:02:16.330 --> 00:02:27.270
The phrase 'other than' means 'not the same
as.'

00:02:27.270 --> 00:02:31.980
A number may be nought, or may be one more
than a number.

00:02:31.980 --> 00:02:36.060
In this way we have a set of
numbers with no bound.

00:02:36.060 --> 00:02:45.860
There are other numbers as well, but I shall
not speak more of them yet.

00:02:45.860 --> 00:02:52.420
These numbers — nought or one more than
a number — can be used to count things.

00:02:52.420 --> 00:02:56.000
We can add
two numbers if we count up from the first

00:02:56.000 --> 00:02:59.280
number while we count down from the number
that

00:02:59.280 --> 00:03:10.340
is not the first till it comes to nought;
then the first count is the sum.

00:03:10.340 --> 00:03:16.810
We shall take the word 'many' to mean 'more
than two — more than two in number.'

00:03:16.810 --> 00:03:21.930
Think of a machine that can keep track of
two numbers, and count each one up or down,

00:03:21.930 --> 00:03:24.430
and
test if a number be nought and by such a test

00:03:24.430 --> 00:03:26.940
choose to do this or that.

00:03:26.940 --> 00:03:29.440
The list of
things that it can do and of choices that

00:03:29.440 --> 00:03:31.980
it can make must be of a known size that is
some

00:03:31.980 --> 00:03:41.370
number.

00:03:41.370 --> 00:03:43.760
Here you can see the two numbers and a list.

00:03:43.760 --> 00:03:45.210
The machine starts its work with the first
row of the list.

00:03:45.210 --> 00:03:50.430
Each row in the list has a state name; the
word 'up' or 'down'; and which

00:03:50.430 --> 00:03:53.710
number to count up or count down.

00:03:53.710 --> 00:03:58.670
For 'up,' we have the name of the next state
to go to-

00:03:58.670 --> 00:04:04.170
and the machine counts the number up by one;
for 'down,' the machine first tests the

00:04:04.170 --> 00:04:08.450
number, and so we have the name of the new
state to go to if the number be nought and

00:04:08.450 --> 00:04:10.130
the
name of the new state to go to if the number

00:04:10.130 --> 00:04:23.130
be other than nought- in which case the
machine counts the number down by one.

00:04:23.130 --> 00:04:28.240
A computer is a machine that can do at least
what that machine can and we have good cause

00:04:28.240 --> 00:04:32.390
to think that if a computer task can be done
at all, then the two number machine can do

00:04:32.390 --> 00:04:35.930
it, too, if you put numbers in and read them
out in the right way.

00:04:35.930 --> 00:04:39.880
In some sense, all
computers are the same; we know this thanks

00:04:39.880 --> 00:04:41.960
to the work of such persons as Alan Turing
and

00:04:41.960 --> 00:04:50.750
Alonzo Church.

00:04:50.750 --> 00:04:53.960
A vocabulary is a set of words.

00:04:53.960 --> 00:04:56.350
A language is a vocabulary and rules for what
a string of

00:04:56.350 --> 00:05:07.380
words might mean to a person or a machine
that hears them.

00:05:07.380 --> 00:05:10.400
To define a word is to tell what it means.

00:05:10.400 --> 00:05:14.930
When you define a word, you add it to your
vocabulary and to the vocabulary of each person

00:05:14.930 --> 00:05:15.930
who hears you.

00:05:15.930 --> 00:05:18.840
Then you can use the word.

00:05:18.840 --> 00:05:25.740
To program is to make up a list of things
to do and choices to make, to be done by a

00:05:25.740 --> 00:05:26.740
computer.

00:05:26.740 --> 00:05:31.930
Such a list is called a program.

00:05:31.930 --> 00:05:40.950
Next, a noun can be made from a verb to mean
that which is done as meant by the verb; to

00:05:40.950 --> 00:05:43.990
make such a noun, we add 'ing' to the verb
stem.

00:05:43.990 --> 00:05:54.500
Thus we can speak of 'programming.'

00:05:54.500 --> 00:05:58.400
A programming language is a language that
we can use to tell a computer a program

00:05:58.400 --> 00:05:59.840
to do.

00:05:59.840 --> 00:06:03.800
Java is a brand name for a computer programming
language.

00:06:03.800 --> 00:06:06.060
I shall speak of the
Java programming language a great deal more

00:06:06.060 --> 00:06:08.820
in this talk.

00:06:08.820 --> 00:06:14.340
I have to say the full phrase
'the Java programming language,' for there

00:06:14.340 --> 00:06:18.480
is a guy who works where I do who deals with
the laws of marks of trade, and he told me

00:06:18.480 --> 00:06:26.870
I have to say it that way.

00:06:26.870 --> 00:06:30.420
Names of other
programming languages are Fortran, APL, Pascal,

00:06:30.420 --> 00:06:36.250
and PL/I.

00:06:36.250 --> 00:06:40.030
A part of a program that does define a new
word for use in other parts of the program

00:06:40.030 --> 00:06:42.430
is called a definition.

00:06:42.430 --> 00:06:44.990
Not all programming languages have a way to
code definitions, but

00:06:44.990 --> 00:06:46.410
most do.

00:06:46.410 --> 00:06:54.900
Those that do not are for wimps.

00:06:54.900 --> 00:06:58.240
Should a programming language be large or
small?

00:06:58.240 --> 00:07:01.680
A small programming language
might take but a short time to learn.

00:07:01.680 --> 00:07:03.780
A large programming language may take a long,
long

00:07:03.780 --> 00:07:07.990
time to learn, but then it is less hard to
use, for then we have a lot of words at hand—

00:07:07.990 --> 00:07:13.590
or, I should say, at the tips of our tongues—to
use at the drop of a hat.

00:07:13.590 --> 00:07:15.990
If we start with
a small language, then in most cases we can

00:07:15.990 --> 00:07:18.330
not say much at the start.

00:07:18.330 --> 00:07:21.280
We must first
define more words; then we can speak of the

00:07:21.280 --> 00:07:27.710
main thing that is on our mind.

00:07:27.710 --> 00:07:31.400
We can use a verb in the past tense if we
add a 'd' or 'ed' sound at the end of the

00:07:31.400 --> 00:07:32.570
verb.

00:07:32.570 --> 00:07:37.180
In the same way we can form what we call a
past participle, which is a form of the

00:07:37.180 --> 00:07:43.850
verb that says of a noun that what the verb
means has been done to it.

00:07:43.850 --> 00:07:48.440
For this talk, I wanted to show you what it
is like to use a language that is much too

00:07:48.440 --> 00:07:50.140
small.

00:07:50.140 --> 00:07:52.360
You have now had a good taste of it.

00:07:52.360 --> 00:07:59.180
I must next define a few more words.

00:07:59.180 --> 00:08:04.670
An example is some one thing, out of a set
of things, that I put in front of you so that

00:08:04.670 --> 00:08:09.380
you can see how some part of that thing is
in fact a part of each thing in the set.

00:08:09.380 --> 00:08:15.979
A syllable is a bit of sound that a mouth
and tongue can say all at one time, more or

00:08:15.979 --> 00:08:19.240
less, in a smooth way.

00:08:19.240 --> 00:08:23.009
Each word is made up of one or more syllables.

00:08:23.009 --> 00:08:27.110
A primitive is a word for which we can take
it for granted that we all know what it

00:08:27.110 --> 00:08:31.500
means.

00:08:31.500 --> 00:08:36.871
For this talk, I chose to take as my primitives
all the words of one syllable, and no

00:08:36.871 --> 00:08:43.580
more, from the language I use for most of
my speech each day, which is called English.

00:08:43.580 --> 00:08:47.480
My firm rule for this talk is that if I need
to use a word of two or more syllables, I

00:08:47.480 --> 00:09:00.610
must first define it.

00:09:00.610 --> 00:09:04.770
Thank you, now you see.

00:09:04.770 --> 00:09:10.959
I can do this by defining one word at a time—and
I have done so—or I can

00:09:10.959 --> 00:09:14.839
give a rule by which a new word can be made
from some other known word, so that many

00:09:14.839 --> 00:09:19.290
new words can be defined at once—and I have
done this as well.

00:09:19.290 --> 00:09:24.611
This choice, to start with just words of one
syllable, was why I had to define the word

00:09:24.611 --> 00:09:32.689
'woman' but could take the word 'man' for
granted.

00:09:32.689 --> 00:09:37.279
I wanted to define 'machine' in terms of the
word 'person', and it seemed least hard to

00:09:37.279 --> 00:09:39.740
define 'person' as 'a man or a woman.'

00:09:39.740 --> 00:09:42.589
But then by chance, the word 'man' has one
syllable

00:09:42.589 --> 00:09:47.089
and so is a primitive, in English, but the
word 'woman' has two syllables and so I had

00:09:47.089 --> 00:09:48.640
to
define it.

00:09:48.640 --> 00:09:51.269
In a language other than English, the words
that mean 'man' and 'woman'

00:09:51.269 --> 00:09:55.459
might each have one syllable—or might each
have two syllables, in which case one would

00:09:55.459 --> 00:10:00.070
have to take some other tack.

00:10:00.070 --> 00:10:05.100
We have to do this a lot when we write real
computer programs: a thought that seems

00:10:05.100 --> 00:10:09.410
like a primitive in our minds turns out not
to be a primitive in a programming language,

00:10:09.410 --> 00:10:12.569
and in each new program we must define it
once more.

00:10:12.569 --> 00:10:16.899
A good example of this is max,
which yields the more large of two numbers.

00:10:16.899 --> 00:10:22.070
It is a primitive thought to me, but few
programming languages have it as a primitive;

00:10:22.070 --> 00:10:23.860
I have to define it.

00:10:23.860 --> 00:10:26.019
This is the sort of
thing that makes a computer look like a person

00:10:26.019 --> 00:10:28.149
who is but four years old.

00:10:28.149 --> 00:10:32.269
Next to English,
all computer programming languages are small;

00:10:32.269 --> 00:10:35.959
as we write code, we must stop now and then
to define some new term that we will need

00:10:35.959 --> 00:10:38.690
to use in more than one place.

00:10:38.690 --> 00:10:40.829
Some persons
find that their programs have a few large

00:10:40.829 --> 00:10:43.149
chunks of code that do the 'real work' plus
a

00:10:43.149 --> 00:10:48.300
large pile of small bits of code that define
new words, so to speak, to be used as if they

00:10:48.300 --> 00:10:50.660
were primitives.

00:10:50.660 --> 00:10:54.540
I hope that this talk brings home to you—in
a way you can feel in your heart, not just

00:10:54.540 --> 00:10:58.470
think in your head—what it is like to have
to program in that way.

00:10:58.470 --> 00:11:01.440
This should show you,
true to life, what it is like to use a small

00:11:01.440 --> 00:11:04.480
language.

00:11:04.480 --> 00:11:07.970
Each time I have tried this sort of
thing, I have found that I can not say much

00:11:07.970 --> 00:11:12.939
at all till I take the time to define at least
a few new terms.

00:11:12.939 --> 00:11:17.649
In other words, if you want to get far at
all with a small language, you

00:11:17.649 --> 00:11:25.699
must first add to the small language to make
a language that is more large.

00:11:25.699 --> 00:11:30.690
In some cases we will find it more smooth
to add the syllable 'er' to the end of a

00:11:30.690 --> 00:11:40.089
word than to use the word 'more' in front
of it; in this way we might say 'smoother'

00:11:40.089 --> 00:11:41.649
in place of 'more smooth.'

00:11:41.649 --> 00:11:49.649
Let me add that better means 'more good.'

00:11:49.649 --> 00:11:53.149
In truth, the words of one syllable form quite
a rich vocabulary, with which you can say

00:11:53.149 --> 00:11:55.089
many things.

00:11:55.089 --> 00:11:58.089
You may note that this vocabulary is much
larger than that of the language

00:11:58.089 --> 00:12:10.709
called Basic English, defined by Charles Kay
Ogden in the year one nine three nought.

00:12:10.709 --> 00:12:15.279
I chose not to use Basic English for this
talk, for the cause being that Basic English

00:12:15.279 --> 00:12:17.739
has
many words of two or more syllables, some

00:12:17.739 --> 00:12:19.339
of them quite long, handed down to us from
the

00:12:19.339 --> 00:12:21.910
dim past of Rome.

00:12:21.910 --> 00:12:25.319
While Basic English has fewer words, it does
not give the feel, to one who

00:12:25.319 --> 00:12:28.470
speaks full English, of being a small language.

00:12:28.470 --> 00:12:35.110
By the way, from now on I shall use the word
because to mean 'the cause being that.'

00:12:35.110 --> 00:12:38.740
If we look at English and then at programming
languages, we see that all our programming

00:12:38.740 --> 00:12:40.069
languages seem small.

00:12:40.069 --> 00:12:43.360
And yet we can say, too, in some cases, that
one programming

00:12:43.360 --> 00:12:47.970
language is smaller than some other programming
language.

00:12:47.970 --> 00:12:53.449
A design is a plan for how to build a thing.

00:12:53.449 --> 00:12:58.699
To design is to build a thing in one’s mind
but not yet in the real world—or, better

00:12:58.699 --> 00:13:02.189
yet, to plan how the real thing can be built.

00:13:02.189 --> 00:13:06.569
The main thing that I want to ask in this
talk is: If I want to help other persons to

00:13:06.569 --> 00:13:12.989
write all sorts of programs, should I design
a small programming language or a large one?

00:13:12.989 --> 00:13:17.670
I stand on this claim: I should not design
a small language, and I should not design

00:13:17.670 --> 00:13:18.809
a large one.

00:13:18.809 --> 00:13:20.920
I need to design a language that can grow.

00:13:20.920 --> 00:13:25.379
I need to plan ways in which it
might grow—but I need, too, to leave some

00:13:25.379 --> 00:13:30.369
choices so that other persons can make those
choices at a later time.

00:13:30.369 --> 00:13:31.730
This is not a new thought.

00:13:31.730 --> 00:13:34.190
We have known for some time that huge programs
can not

00:13:34.190 --> 00:13:36.329
be coded from scratch all at once.

00:13:36.329 --> 00:13:39.529
There has to be a plan for growth.

00:13:39.529 --> 00:13:42.170
What we must
think on now is the fact that languages have

00:13:42.170 --> 00:13:46.569
now reached that large size where they
can not be designed all at once, much less

00:13:46.569 --> 00:13:51.220
built all at once.

00:13:51.220 --> 00:13:57.560
Let me pause to define some names for numbers.

00:13:57.560 --> 00:13:59.829
Twenty is twice ten.

00:13:59.829 --> 00:14:04.489
Thirty is thrice
ten.

00:14:04.489 --> 00:14:06.629
Forty is twice twenty.

00:14:06.629 --> 00:14:08.910
A hundred is ten times ten.

00:14:08.910 --> 00:14:12.480
A million is a hundred times a
hundred times a hundred.

00:14:12.480 --> 00:14:14.579
Sixteen is twice eight.

00:14:14.579 --> 00:14:17.199
Seven is one plus six.

00:14:17.199 --> 00:14:23.619
Fifty is one more
than seven squared.

00:14:23.619 --> 00:14:30.629
One more thing: ago means 'in the past, counting
back from now.'

00:14:30.629 --> 00:14:35.170
In the past, it made sense to design a whole
language, once for all.

00:14:35.170 --> 00:14:38.209
Fortran was a small
language forty years ago, designed for tasks

00:14:38.209 --> 00:14:40.149
with numbers, and it served well.

00:14:40.149 --> 00:14:43.580
PL/I was
thought a big language thirty years ago, but

00:14:43.580 --> 00:14:46.420
now we would think of it as small.

00:14:46.420 --> 00:14:48.519
Pascal
was designed as a small, whole language with

00:14:48.519 --> 00:14:51.420
no plan to add to it later.

00:14:51.420 --> 00:14:55.470
That
was five and twenty years ago.

00:14:55.470 --> 00:14:57.860
What came to pass?

00:14:57.860 --> 00:14:59.589
Fortran has grown and grown.

00:14:59.589 --> 00:15:01.230
Many new words and new rules have been added.

00:15:01.230 --> 00:15:03.329
The
new design is not bad; the parts fit well,

00:15:03.329 --> 00:15:05.389
one with the other.

00:15:05.389 --> 00:15:09.459
But to many programmers who
have used Fortran for a long time, the Fortran

00:15:09.459 --> 00:15:13.870
of here and now is not at all the same as
the language they first came to know and love.

00:15:13.870 --> 00:15:15.329
It looks strange.

00:15:15.329 --> 00:15:18.999
PL/I has not grown much.

00:15:18.999 --> 00:15:21.220
It is, for the most part, just as it was when
it first came

00:15:21.220 --> 00:15:23.029
out.

00:15:23.029 --> 00:15:25.399
It may be that this is just from lack of use.

00:15:25.399 --> 00:15:28.739
The flip side is that the lack of use
may have two causes.

00:15:28.739 --> 00:15:32.519
Number one: PL/I was not designed to grow—it
was designed to be all

00:15:32.519 --> 00:15:35.699
things to all who program right from the start.

00:15:35.699 --> 00:15:39.170
Number two: for its time, it started out
large.

00:15:39.170 --> 00:15:44.989
No one knew all of PL/I; some said that no
one could know all of PL/I.

00:15:44.989 --> 00:15:49.420
Pascal grew just a tad and was used to build
many large programs.

00:15:49.420 --> 00:15:51.709
One main fault of
the first design was that strings were hard

00:15:51.709 --> 00:15:55.240
to use because they were all of fixed size.

00:15:55.240 --> 00:15:58.970
Pascal would have been of no use for the building
of large programs for use in the real

00:15:58.970 --> 00:16:00.470
world if this had not been changed.

00:16:00.470 --> 00:16:03.410
But Wirth had not planned for the language
to change

00:16:03.410 --> 00:16:07.980
in such ways, and in fact few changes were
made.

00:16:07.980 --> 00:16:11.939
At times we think of C as a small language
designed from whole cloth.

00:16:11.939 --> 00:16:14.050
But it grew
out of a smaller language called B, and has

00:16:14.050 --> 00:16:15.529
since grown to be a larger language called
C

00:16:15.529 --> 00:16:18.110
plus plus.

00:16:18.110 --> 00:16:21.769
A language as large as C plus plus could not
have spread so wide if it had been

00:16:21.769 --> 00:16:23.160
foisted on the world all at once.

00:16:23.160 --> 00:16:29.089
It would have been too hard to port.

00:16:29.089 --> 00:16:34.379
One more rule for making words: if we add
the syllable 'er' to a verb stem, we make

00:16:34.379 --> 00:16:38.779
a noun that names a person or thing that does
what the verb says to do.

00:16:38.779 --> 00:16:40.779
For example, a
buyer is one who buys.

00:16:40.779 --> 00:16:46.740
A user is one who does use.

00:16:46.740 --> 00:16:50.290
As you may by now have guessed, I am of like
mind with my good friend Dick Gabriel,

00:16:50.290 --> 00:16:56.759
here in the front row, who wrote the well
known screed 'Worse Is Better'.

00:16:56.759 --> 00:17:00.970
The real name
was 'Lisp: Good News, Bad News, How to Win

00:17:00.970 --> 00:17:09.350
Big,' which is all words of just one syllable—
which might seem like good luck for me, but

00:17:09.350 --> 00:17:13.470
the truth is that Dick Gabriel knew how to
choose words with punch.

00:17:13.470 --> 00:17:16.380
Yet what first comes to mind for most persons
is the part headed

00:17:16.380 --> 00:17:24.400
'Worse Is Better' and so that's how they cite
it.

00:17:24.400 --> 00:17:27.920
The gist of it is that the best way to get
a language used by many persons is not to

00:17:27.920 --> 00:17:32.410
design and build 'The Right Thing,' because
that will take too long.

00:17:32.410 --> 00:17:35.450
In a race, a small
language with warts will beat a well designed

00:17:35.450 --> 00:17:39.770
language because users will not wait for the
right thing; they will use the language that

00:17:39.770 --> 00:17:42.230
is quick and cheap, and put up with the
warts.

00:17:42.230 --> 00:17:46.750
Once a small language fills a niche, it is
hard to take its place.

00:17:46.750 --> 00:17:52.260
Well, then, could not 'The Right Thing' be
a small language, not hard to port but

00:17:52.260 --> 00:17:53.990
with no warts?

00:17:53.990 --> 00:17:59.010
I guess it could be done, but I, for one,
am not that smart-or have not had that much

00:17:59.010 --> 00:18:00.200
luck.

00:18:00.200 --> 00:18:03.110
But in fact I think it can not be done.

00:18:03.110 --> 00:18:06.960
Five and twenty years ago, when users did
not want that much from a language, one could

00:18:06.960 --> 00:18:08.130
try.

00:18:08.130 --> 00:18:11.760
Scheme was my best shot at it.

00:18:11.760 --> 00:18:15.600
But users will not now with glad cries glom
on to a language that gives them no more

00:18:15.600 --> 00:18:18.350
than what Scheme or Pascal gave them.

00:18:18.350 --> 00:18:20.380
They need to paint bits, lines, and boxes
on the

00:18:20.380 --> 00:18:25.500
screen in hues bright and wild; they need
to talk to printers and servers through the

00:18:25.500 --> 00:18:27.850
net;
they need to load code on the fly; they need

00:18:27.850 --> 00:18:32.020
their programs to work with other code they
don’t trust; they need to run code in many

00:18:32.020 --> 00:18:36.630
threads and on many machines; they need to
deal with text and sayings in all the world’s

00:18:36.630 --> 00:18:37.630
languages.

00:18:37.630 --> 00:18:41.850
A small programming language
just won’t cut it.

00:18:41.850 --> 00:18:45.930
So a small language can not do the job right
and a large language takes too long to

00:18:45.930 --> 00:18:47.810
get off the ground.

00:18:47.810 --> 00:18:50.430
Are we doomed to use small languages with
many warts because that

00:18:50.430 --> 00:18:55.350
is the sole kind of design that can make it
in the world?

00:18:55.350 --> 00:18:58.520
At one time this thought filled me with gloom.

00:18:58.520 --> 00:19:01.260
But then I saw a gap in my thinking.

00:19:01.260 --> 00:19:05.820
I said that users will not wait for 'The Right
Thing,' but will use what comes first and

00:19:05.820 --> 00:19:07.560
put up with the warts.

00:19:07.560 --> 00:19:12.130
But—users will not put up with the warts
for all time.

00:19:12.130 --> 00:19:14.740
It is not
long till they scream and moan and beg for

00:19:14.740 --> 00:19:15.740
changes.

00:19:15.740 --> 00:19:17.810
The small language will grow.

00:19:17.810 --> 00:19:22.420
The
warts will be shaved off or patched.

00:19:22.420 --> 00:19:26.370
If one person does all the work, then growth
will be slow.

00:19:26.370 --> 00:19:32.400
But if one lets the users help
do the work, growth can be quick.

00:19:32.400 --> 00:19:34.620
If many persons work side by side, and the
best work

00:19:34.620 --> 00:19:47.490
is added with care and good taste, a great
deal can be added in a short time.

00:19:47.490 --> 00:19:52.520
APL was designed by one man, a smart man—and
I love APL—but it had a flaw that

00:19:52.520 --> 00:19:56.820
I think has all but killed it: there was no
way for a user to grow the language in a

00:19:56.820 --> 00:19:58.950
smooth way.

00:19:58.950 --> 00:20:02.530
In most languages, a user can define at least
some new words to stand for

00:20:02.530 --> 00:20:07.550
other pieces of code that can then be called,
in such a way that the new words look like

00:20:07.550 --> 00:20:09.200
primitives.

00:20:09.200 --> 00:20:13.060
In this way the user can build a larger language
to meet his needs.

00:20:13.060 --> 00:20:16.770
But in
APL, new words defined by the user do not

00:20:16.770 --> 00:20:18.920
look like language primitives at all.

00:20:18.920 --> 00:20:22.161
The name
of a piece of user code is a word, but things

00:20:22.161 --> 00:20:26.040
that are built in are named by strange
glyphs.

00:20:26.040 --> 00:20:29.530
To add what look like new trick primitives,
to keep the feel of the language,

00:20:29.530 --> 00:20:32.270
takes a real hacker and a ton of work.

00:20:32.270 --> 00:20:34.020
This has stopped users from helping to grow
the

00:20:34.020 --> 00:20:35.130
language.

00:20:35.130 --> 00:20:39.470
APL has grown some, but the work has been
done by just the few programmers that

00:20:39.470 --> 00:20:40.540
have the source code.

00:20:40.540 --> 00:20:45.320
If a user adds to APL, and what he added seems
good to the hackers

00:20:45.320 --> 00:20:50.680
in charge of the language, they might then
make it be built in, but code to use it would

00:20:50.680 --> 00:20:55.220
not look the same; the user would have to
change his code to a new form, because in

00:20:55.220 --> 00:20:57.530
APL a
use of what is built in does not look at all

00:20:57.530 --> 00:21:09.280
like a call to user code.

00:21:09.280 --> 00:21:13.350
Lisp was designed by one man, a smart man,
and it works in a way that I think he

00:21:13.350 --> 00:21:15.260
did not plan for.

00:21:15.260 --> 00:21:18.900
In Lisp, new words defined by the user look
like primitives and, what

00:21:18.900 --> 00:21:22.900
is more, all primitives look like words defined
by the user.

00:21:22.900 --> 00:21:26.480
In other words, if a user has
good taste in defining new words, what comes

00:21:26.480 --> 00:21:29.420
out is a larger language that has no seams.

00:21:29.420 --> 00:21:33.870
The designer in charge can grow the language
with close to no work on his part, just by

00:21:33.870 --> 00:21:36.890
choosing with care from the work of many users.

00:21:36.890 --> 00:21:41.500
And Lisp grew much faster than APL
did, because many users could try things out

00:21:41.500 --> 00:21:46.290
and put their best code out there for other
users to use and to add to the language.

00:21:46.290 --> 00:21:50.500
Lisp is not used quite as much as it used
to be, but parts of it live on in other

00:21:50.500 --> 00:21:57.380
languages, the best of which is called garbage
collection-and I will not try to tell you

00:21:57.380 --> 00:22:05.800
now what that means in words of one syllable—I
leave it to you as a task to try in your

00:22:05.800 --> 00:22:08.150
spare time.

00:22:08.150 --> 00:22:11.740
It is not that hard.

00:22:11.740 --> 00:22:15.680
This leads me to claim that, from now on,
a main goal in designing a language should

00:22:15.680 --> 00:22:17.400
be to plan for growth.

00:22:17.400 --> 00:22:20.490
The language must start small, and the language
must grow as the

00:22:20.490 --> 00:22:23.000
set of users grows.

00:22:23.000 --> 00:22:26.170
I now think that I, as a language designer
helping out with the Java

00:22:26.170 --> 00:22:31.510
programming language, need to ask not 'Should
the Java programming language grow?'

00:22:31.510 --> 00:22:34.990
but 'How should the Java programming language
grow?'

00:22:34.990 --> 00:22:38.590
There is more than one kind of growth and
more than one way to do it.

00:22:38.590 --> 00:22:41.090
But, as we
shall see, if the goal is to be quick and

00:22:41.090 --> 00:22:43.460
yet to do good work, one mode may be better
by

00:22:43.460 --> 00:22:45.730
far than all other modes.

00:22:45.730 --> 00:22:49.700
There are two kinds of growth in a language.

00:22:49.700 --> 00:22:53.150
One can change the vocabulary, or one
can change the rules that say what a string

00:22:53.150 --> 00:23:03.300
of words means.

00:23:03.300 --> 00:23:07.500
A library is a vocabulary designed to be added
to a programming language to make its

00:23:07.500 --> 00:23:09.750
vocabulary larger.

00:23:09.750 --> 00:23:12.540
A true library does not change the rules of
meaning for the language;

00:23:12.540 --> 00:23:14.880
it just adds new words.

00:23:14.880 --> 00:23:18.350
You can see from this that, in my view, the
code that lets you do

00:23:18.350 --> 00:23:21.310
a 'long jump' in C is not a true library.

00:23:21.310 --> 00:23:25.280
Of course, there must be a way for a user
to make libraries.

00:23:25.280 --> 00:23:28.960
But the key point is that
the new words defined by a library should

00:23:28.960 --> 00:23:32.530
look just like the primitives of the language.

00:23:32.530 --> 00:23:35.210
Some languages are like this and some are
not.

00:23:35.210 --> 00:23:40.500
Those that are not are harder to grow with
the help of users.

00:23:40.500 --> 00:23:44.780
It may be good as well to have a way to add
to the rules of meaning for a language.

00:23:44.780 --> 00:23:47.460
Some ways to do this work better than others.

00:23:47.460 --> 00:23:51.460
But in the same way, the language should let
work done by a user look just like what was

00:23:51.460 --> 00:23:53.110
designed at the start.

00:23:53.110 --> 00:23:56.290
I would like to grow
the Java brand programming language in such

00:23:56.290 --> 00:23:59.900
a way that users can do more of this.

00:23:59.900 --> 00:24:03.340
In the same way, there are two ways to do
the growing.

00:24:03.340 --> 00:24:06.590
One is for one person-or
a small group-to be in charge and to take

00:24:06.590 --> 00:24:11.020
in, test, judge, and add the work done by
other

00:24:11.020 --> 00:24:12.020
persons.

00:24:12.020 --> 00:24:14.840
The other way is to just put all the source
code out there, once things start to

00:24:14.840 --> 00:24:17.190
work, and let each person do as he wills.

00:24:17.190 --> 00:24:19.660
To have a person in charge can slow things
down,

00:24:19.660 --> 00:24:26.380
but to have no one in charge makes it harder
to add up the work of many persons.

00:24:26.380 --> 00:24:30.220
The way that I think is faster and better
than all others does both.

00:24:30.220 --> 00:24:33.850
Put the source code
out there and let all persons play with it.

00:24:33.850 --> 00:24:37.760
Have a person in charge who is a quick judge
of good work and who will take it in and shove

00:24:37.760 --> 00:24:39.770
it back out fast.

00:24:39.770 --> 00:24:41.510
You don’t have to use
what he ships, and you don’t have to give

00:24:41.510 --> 00:24:43.850
back your work, but he gives all persons a
fast

00:24:43.850 --> 00:24:47.300
way to spread new code to those who want it.

00:24:47.300 --> 00:24:52.750
The best example of this way to do things
is Linux, which is an operating system, which

00:24:52.750 --> 00:24:57.370
is a program that keeps track of other programs
in a computer and gives each its due in

00:24:57.370 --> 00:25:02.500
time and space.

00:25:02.500 --> 00:25:08.200
You like that?

00:25:08.200 --> 00:25:11.960
You ought to read what Eric Raymond had to
say of how Linux came to be.

00:25:11.960 --> 00:25:13.330
I shall
tell you a bit of it once I define two more

00:25:13.330 --> 00:25:18.590
words for you.

00:25:18.590 --> 00:25:22.430
A cathedral is a huge church.

00:25:22.430 --> 00:25:26.720
It may be made of stone; it may fill you with
awe; but

00:25:26.720 --> 00:25:32.070
the key thought, in the mind of Eric Raymond,
is that there is but one design, one grand

00:25:32.070 --> 00:25:36.570
plan, which may take a long time—many years—to
make real.

00:25:36.570 --> 00:25:39.430
As the years pass, few changes are made to
the plan.

00:25:39.430 --> 00:25:44.860
Many, many persons are needed to
build it, but there is just one designer.

00:25:44.860 --> 00:25:49.440
A bazaar is a place with many small shops
or stalls, where you can buy things from

00:25:49.440 --> 00:25:52.380
many persons who are there to sell their wares.

00:25:52.380 --> 00:25:55.750
The key thought here is that each one
sells what he wants to sell and each one buys

00:25:55.750 --> 00:25:57.280
what he wants to buy.

00:25:57.280 --> 00:26:00.540
There is no one plan
and each seller or buyer may change his mind

00:26:00.540 --> 00:26:03.640
at any time.

00:26:03.640 --> 00:26:08.550
Eric Raymond wrote a short work called 'The
Cathedral and the Bazaar' in which he

00:26:08.550 --> 00:26:11.930
looks at how programs are built or have been
built in the past.

00:26:11.930 --> 00:26:14.950
You can find it on his
web site.

00:26:14.950 --> 00:26:17.460
He talks of how he built a mail fetching program
with the help of more

00:26:17.460 --> 00:26:19.850
than two hundred users.

00:26:19.850 --> 00:26:24.200
He quotes Fred Brooks as saying, 'More users
find more bugs,'

00:26:24.200 --> 00:26:30.230
and backs him up with tales from this example
of building a program in the bazaar style.

00:26:30.230 --> 00:26:34.760
As for the role of programmer in charge, Eric
Raymond says that it is fine to come

00:26:34.760 --> 00:26:38.430
up with good thoughts, but much better to
know them when you see them in the works of

00:26:38.430 --> 00:26:39.970
other persons.

00:26:39.970 --> 00:26:41.810
You can get a lot more done that way.

00:26:41.810 --> 00:26:46.360
Linux rose to its heights of fame
and wide use in much the same way, though

00:26:46.360 --> 00:26:49.280
on a much larger scale.

00:26:49.280 --> 00:26:53.100
To take this thought
to the far end of the line: it may be that

00:26:53.100 --> 00:26:57.840
one could write an operating system by putting
a million apes to work at a million typing

00:26:57.840 --> 00:27:01.700
machines, then just spotting the bits of good
work that come out by chance and pasting them

00:27:01.700 --> 00:27:03.920
up to make a whole.

00:27:03.920 --> 00:27:06.070
That might take a
long time, I guess.

00:27:06.070 --> 00:27:08.710
Too bad.

00:27:08.710 --> 00:27:12.380
But the key point of the bazaar is not that
you can get many persons to work with

00:27:12.380 --> 00:27:16.060
you at a task, for cathedral builders had
a great deal of help, too.

00:27:16.060 --> 00:27:19.340
Nor is the key point
that you get help with the designing as well

00:27:19.340 --> 00:27:21.050
as with the building, though that in fact
is

00:27:21.050 --> 00:27:22.540
a big win.

00:27:22.540 --> 00:27:27.230
No, the key point is that in the bazaar style
of building a program or

00:27:27.230 --> 00:27:33.750
designing a language or what you will, the
plan can change in real time to meet the needs

00:27:33.750 --> 00:27:36.400
of those who are working on it.

00:27:36.400 --> 00:27:39.340
This tends to make users stay with it as time
goes by;

00:27:39.340 --> 00:27:43.330
they will take joy in working hard and helping
out if they know that their wants and needs

00:27:43.330 --> 00:27:48.790
have some weight and their hard work can change
the plan for the better.

00:27:48.790 --> 00:27:51.830
Their better.

00:27:51.830 --> 00:27:55.150
Which brings me to the high point of my talk.

00:27:55.150 --> 00:28:03.530
It seems, in the last few years, at least,
that if one is asked to speak at this meeting,

00:28:03.530 --> 00:28:09.570
one must quote Christopher Alexander.

00:28:09.570 --> 00:28:11.350
I
know a bit of his work, though not a lot,

00:28:11.350 --> 00:28:14.970
and I must say thanks to Dick Gabriel for
pointing out to me a quote that has a lot

00:28:14.970 --> 00:28:17.010
to do with the main point of this talk.

00:28:17.010 --> 00:28:25.930
I am sad to say that I do not know what this
quote means, because Christopher Alexander

00:28:25.930 --> 00:28:34.460
uses many words of more than one syllable
and does not define them first.

00:28:34.460 --> 00:28:37.780
But I have
learned to say these words by rote and it

00:28:37.780 --> 00:28:43.280
may be that you out there can glean some
thoughts of use to you.

00:28:43.280 --> 00:28:50.530
Christopher Alexander says:
Master plans have two additional unhealthy

00:28:50.530 --> 00:28:53.700
characteristics.

00:28:53.700 --> 00:28:57.470
To begin with,
the existence of a master plan alienates the

00:28:57.470 --> 00:29:03.690
users ... After all, the very existence
of a master plan means, by definition, that

00:29:03.690 --> 00:29:06.800
the members of the community
can have little impact on the future shape

00:29:06.800 --> 00:29:10.180
of their community, because most
of the important decisions have already been

00:29:10.180 --> 00:29:11.740
made.

00:29:11.740 --> 00:29:16.230
In a sense, under a master
plan people are living with a frozen future,

00:29:16.230 --> 00:29:20.180
able to affect only relatively trivial
details.

00:29:20.180 --> 00:29:23.090
When people lose the sense of responsibility
for the environment they

00:29:23.090 --> 00:29:28.061
live in, and realize that they are merely
cogs in someone else’s machine, how

00:29:28.061 --> 00:29:31.670
can they feel any sense of identification
with the community, or any sense of

00:29:31.670 --> 00:29:35.860
purpose there?

00:29:35.860 --> 00:29:40.200
I think this means, in part, that it is good
to give your users a chance to buy in and

00:29:40.200 --> 00:29:41.200
to pitch in.

00:29:41.200 --> 00:29:44.430
It is good for them and it is good for you.

00:29:44.430 --> 00:29:49.130
In point of fact, a number of
cathedrals were built in the bazaar mode.

00:29:49.130 --> 00:29:55.310
Does this mean, then, that it is of no use
to design?

00:29:55.310 --> 00:29:56.600
Not at all.

00:29:56.600 --> 00:30:00.480
But in stead of
designing a thing, you need to design a way

00:30:00.480 --> 00:30:01.750
of doing.

00:30:01.750 --> 00:30:05.770
And this way of doing must make
some choices now but leave other choices to

00:30:05.770 --> 00:30:07.990
a later time.

00:30:07.990 --> 00:30:19.900
Which brings me to the word you have all been
waiting for: a pattern is a plan that has

00:30:19.900 --> 00:30:25.309
some number of parts and shows you how each
part turns a face to the other parts, how

00:30:25.309 --> 00:30:30.350
each joins with the others or stands off,
how each part does what it does and how the

00:30:30.350 --> 00:30:35.660
other parts aid it or drag it down, and how
all the parts may be grasped as a whole and

00:30:35.660 --> 00:30:40.870
made to serve as one thing, for some higher
goal or as part of a larger pattern.

00:30:40.870 --> 00:30:43.510
A pattern
should give hints or clues as to when and

00:30:43.510 --> 00:30:46.790
where it is best put to use.

00:30:46.790 --> 00:30:49.960
What is more, some
of the parts of a pattern may be holes, or

00:30:49.960 --> 00:30:54.100
slots, in which other things may be placed
later.

00:30:54.100 --> 00:30:58.320
A good pattern will say how changes can be
made in the course of time.

00:30:58.320 --> 00:31:01.390
Thus
some choices of the plan are built in as part

00:31:01.390 --> 00:31:07.110
of the pattern, and other choices wait till
the time when the pattern is to be used.

00:31:07.110 --> 00:31:10.430
In this way a pattern stands for a design
space

00:31:10.430 --> 00:31:19.710
in which you can choose, on the fly, your
own path for growth and change.

00:31:19.710 --> 00:31:23.670
It is good to design a thing, but it can be
far better-and far harder-to design a

00:31:23.670 --> 00:31:25.130
pattern.

00:31:25.130 --> 00:31:30.350
Best of all is to know when to use a pattern.

00:31:30.350 --> 00:31:33.370
Now for some more computer words.

00:31:33.370 --> 00:31:41.820
A datum is a set of bits that has a meaning;
data is the mass noun for a set of datums.

00:31:41.820 --> 00:31:45.920
An object is a datum the meanings of whose
parts is laid down by a set of language

00:31:45.920 --> 00:31:47.230
rules.

00:31:47.230 --> 00:31:50.960
In the Java programming language, these rules
use types to make clear which parts

00:31:50.960 --> 00:31:55.820
of an object may cite other objects.

00:31:55.820 --> 00:31:58.070
Objects may be grouped to form classes.

00:31:58.070 --> 00:32:01.260
Knowing the class of an object tells you most
of what you need to know of how that object

00:32:01.260 --> 00:32:03.280
acts.

00:32:03.280 --> 00:32:07.010
Objects may have fields; each field of an
object can hold a datum.

00:32:07.010 --> 00:32:10.490
Which datum it
holds may change from time to time.

00:32:10.490 --> 00:32:12.570
Each field may have a type, which tells you
what

00:32:12.570 --> 00:32:18.150
data can be in that field at run time-and,
what is more, it tells you what data can not

00:32:18.150 --> 00:32:21.559
be in that field at run time.

00:32:21.559 --> 00:32:25.190
A method is a named piece of code that is
part of an object.

00:32:25.190 --> 00:32:28.100
If you can name or cite
an object, then you can call a method of that

00:32:28.100 --> 00:32:33.570
object; the method then does its thing.

00:32:33.570 --> 00:32:37.990
The Java programming language has objects
and classes and fields and methods and

00:32:37.990 --> 00:32:39.390
types.

00:32:39.390 --> 00:32:42.770
Now I shall speak of some things that the
Java programming language does not yet

00:32:42.770 --> 00:32:46.070
have.

00:32:46.070 --> 00:32:54.040
A generic type is a map from one or more types
to types.

00:32:54.040 --> 00:32:58.690
Put another way, a generic
type is a pattern for building types.

00:32:58.690 --> 00:33:00.990
A number of groups of persons have set forth
ways

00:33:00.990 --> 00:33:04.640
to add generic types to the Java programming
language; each way has its

00:33:04.640 --> 00:33:06.580
own good points.

00:33:06.580 --> 00:33:10.770
We heard three talks on adding generic types
to the Java programming language at this

00:33:10.770 --> 00:33:17.140
meeting less than three and twenty hours ago.

00:33:17.140 --> 00:33:21.809
An operator is a glyph, such as a plus sign,
that can be used in a language as if it were

00:33:21.809 --> 00:33:22.820
a word.

00:33:22.820 --> 00:33:27.350
In the C or the Java programming language,
as in English, the sign first known as

00:33:27.350 --> 00:33:46.120
'and per se and' is an operator, but a full
stop or quote mark is not an operator.

00:33:46.120 --> 00:33:50.640
A word is said to be overloaded if it is made
to mean two or more things and the hearer

00:33:50.640 --> 00:33:54.400
has to choose the meaning based on the rest
of what is said.

00:33:54.400 --> 00:33:58.371
For example, using the rules
defined near the start of this talk, a verb

00:33:58.371 --> 00:34:04.120
form such as 'painted' might be a past tense
or a past participle, and it is up to you,

00:34:04.120 --> 00:34:06.310
the hearer, to make the call as to which I
mean

00:34:06.310 --> 00:34:08.240
when I say it.

00:34:08.240 --> 00:34:10.970
Sometimes an overloaded word is called polymorphic,
which means that the

00:34:10.970 --> 00:34:18.609
word has many forms; but the truth is that
the word has but one form, and many meanings.

00:34:18.609 --> 00:34:24.210
The definition of a word may be polymorphic,
but the word as such is not.

00:34:24.210 --> 00:34:28.409
An operator can be overloaded in C plus plus,
but right now operators in the Java

00:34:28.409 --> 00:34:32.600
programming language can not be overloaded
by the programmer, even though the names of

00:34:32.600 --> 00:34:34.919
methods may be overloaded.

00:34:34.919 --> 00:34:36.280
I would like to change that.

00:34:36.280 --> 00:34:41.109
I have said in the past, and will say now,
that I think it would be a good thing for

00:34:41.109 --> 00:34:44.889
the Java programming language to add generic
types and to let the user define overloaded

00:34:44.889 --> 00:34:46.750
operators.

00:34:46.750 --> 00:34:50.230
Just as a user can code methods in just the
same way as methods that are built

00:34:50.230 --> 00:34:55.429
in, the user ought to have a way to define
operators for user defined classes that can

00:34:55.429 --> 00:34:57.811
be
used in just the same way as operators that

00:34:57.811 --> 00:34:59.940
are built in.

00:34:59.940 --> 00:35:03.940
What is more, I would add a kind
of class that is of light weight, one whose

00:35:03.940 --> 00:35:06.460
objects can be cloned at will with no harm
and

00:35:06.460 --> 00:35:10.849
so could be kept on a stack for speed and
not just in the heap.

00:35:10.849 --> 00:35:13.829
Classes of this kind would
be well suited for use as user defined number

00:35:13.829 --> 00:35:16.960
types but would have other uses, too.

00:35:16.960 --> 00:35:18.740
You
can find a plan for all this on a web page

00:35:18.740 --> 00:35:20.020
by James Gosling.

00:35:20.020 --> 00:35:26.560
There are a few other things we could add
as well, such as tail calls and ways to read

00:35:26.560 --> 00:35:29.049
and
write those machine flags for numbers whose

00:35:29.049 --> 00:35:34.609
points float.

00:35:34.609 --> 00:35:37.500
But these are small language
tweaks next to generic types and overloaded

00:35:37.500 --> 00:35:39.749
operators.

00:35:39.749 --> 00:35:44.130
If we grow the language in these few ways,
then I think we will not need to grow it in

00:35:44.130 --> 00:35:46.309
a
hundred other ways; the users can take on

00:35:46.309 --> 00:35:47.309
the rest of the task.

00:35:47.309 --> 00:35:53.240
To see why, think on these
examples.

00:35:53.240 --> 00:35:56.640
A complex number is a pair of numbers.

00:35:56.640 --> 00:35:58.260
There are rules for how to find the sum of
two

00:35:58.260 --> 00:36:04.069
complex numbers, or a complex number times
a complex number.

00:36:04.069 --> 00:36:08.210
Some programmers like to use them lot; others
do not use them at all.

00:36:08.210 --> 00:36:11.420
So should we make
'complex number' a type in the Java programming

00:36:11.420 --> 00:36:13.049
language?

00:36:13.049 --> 00:36:18.049
Some say yes, of course; many
others say no.

00:36:18.049 --> 00:36:23.630
A rational number is a pair of numbers.

00:36:23.630 --> 00:36:27.630
There are rules-not the same as the rules
for complex numbers, of course-for how to

00:36:27.630 --> 00:36:32.519
find the sum of two rational numbers, or a
rational number times a rational number.

00:36:32.519 --> 00:36:36.150
A few programmers like to use them a lot;
most do not use them at all.

00:36:36.150 --> 00:36:39.200
So should we make
'rational number' a type in the Java programming

00:36:39.200 --> 00:36:45.530
language?

00:36:45.530 --> 00:36:48.160
An interval is a pair of numbers.

00:36:48.160 --> 00:36:51.329
There are rules-not the same as the rules
for complex

00:36:51.329 --> 00:36:54.489
numbers or rational numbers, of course-for
how to find the sum of two intervals, or an

00:36:54.489 --> 00:36:57.410
interval times an interval.

00:36:57.410 --> 00:37:00.529
A few programmers like to use them a lot and
wish all the other programmers who use

00:37:00.529 --> 00:37:06.480
numbers would use them, too; but most do not
use them at all.

00:37:06.480 --> 00:37:09.750
So should we make
'interval' a type in the Java programming

00:37:09.750 --> 00:37:13.989
language?

00:37:13.989 --> 00:37:19.569
John Horton Conway once defined a game to
be a pair of sets of games- see his book

00:37:19.569 --> 00:37:23.640
On Numbers and Games- then pointed out that
some games may be thought of as

00:37:23.640 --> 00:37:27.400
numbers that say how many moves it will take
to win the game.

00:37:27.400 --> 00:37:30.569
There are rules for how
to find the sum of two games, and so on.

00:37:30.569 --> 00:37:34.749
From this he worked out for hundreds of kinds
of real games how to know which player will

00:37:34.749 --> 00:37:36.809
win.

00:37:36.809 --> 00:37:43.410
I think, oh, three persons in the world know
how to use this kind of number.

00:37:43.410 --> 00:37:44.800
Should
we make it a type in the Java programming

00:37:44.800 --> 00:37:50.769
language?

00:37:50.769 --> 00:37:54.769
A vector is a row of numbers all of the same
type, with each place in the row named

00:37:54.769 --> 00:37:58.380
by the kind of number we first spoke of in
this talk.

00:37:58.380 --> 00:38:02.430
There are rules ... In fact, for
vectors of length three there are two ways

00:38:02.430 --> 00:38:10.309
to do 'a vector times a vector,' so you can
have twice the fun!

00:38:10.309 --> 00:38:13.299
Vectors of length three or four are a great
aid in making bits on the screen look like

00:38:13.299 --> 00:38:16.400
scenes in the real world.

00:38:16.400 --> 00:38:18.359
So should we make 'vector' a type in the Java
programming

00:38:18.359 --> 00:38:21.230
language?

00:38:21.230 --> 00:38:24.460
A matrix is a set of numbers laid out in a
square.

00:38:24.460 --> 00:38:28.040
And there are rules.

00:38:28.040 --> 00:38:31.319
So should we make
'matrix' a type in the Java programming language?

00:38:31.319 --> 00:38:36.029
And so on, and so on, and so on.

00:38:36.029 --> 00:38:41.829
I might say 'yes' to each one of these, but
it is clear that I must say 'no' to all of

00:38:41.829 --> 00:38:43.319
them!

00:38:43.319 --> 00:38:45.539
And so would James Gosling and Bill Joy.

00:38:45.539 --> 00:38:51.170
To add them all to the Java programming
language would be just too much.

00:38:51.170 --> 00:38:53.049
Some parts of the programming vocabulary are
fit for

00:38:53.049 --> 00:38:57.130
all programmers to use, but other parts are
just for their own niches.

00:38:57.130 --> 00:38:59.089
It would not be
fair to weigh down all programmers with the

00:38:59.089 --> 00:39:03.999
need to have or to learn all the words for
every niche used.

00:39:03.999 --> 00:39:07.460
We should not make the Java programming language
a cathedral, but a

00:39:07.460 --> 00:39:10.049
plain bazaar might be too loose.

00:39:10.049 --> 00:39:13.039
What we need is more like a shopping mall,
where there

00:39:13.039 --> 00:39:17.190
are not quite as many choices but most of
the goods are well designed and sellers stand

00:39:17.190 --> 00:39:20.109
up
and back what they sell.

00:39:20.109 --> 00:39:23.119
I could speak at length on the ways in which
a shopping mall is

00:39:23.119 --> 00:39:27.599
like a cathedral—but not here, not now!

00:39:27.599 --> 00:39:32.549
Now, the user could define objects for such
numbers to have methods that act in the

00:39:32.549 --> 00:39:39.530
right ways, but code to use such numbers would
look strange and be slow.

00:39:39.530 --> 00:39:48.749
Programmers used
to adding numbers with plus signs would kvetch.

00:39:48.749 --> 00:39:52.829
In fact, the Java programming language
does have a class of 'big numbers' that have

00:39:52.829 --> 00:39:54.210
methods for adding them and telling which
is

00:39:54.210 --> 00:39:58.849
larger and all the rest, and you can not use
the plus sign to add such numbers, and

00:39:58.849 --> 00:40:03.769
programmers who have to use them do kvetch.

00:40:03.769 --> 00:40:07.109
Generic types and overloaded operators would
let a user code up all of these, and in

00:40:07.109 --> 00:40:11.390
such a way that they would look in all ways
just like types that are built in.

00:40:11.390 --> 00:40:14.630
They would
let users grow the Java programming language

00:40:14.630 --> 00:40:16.339
in a smooth and clean way.

00:40:16.339 --> 00:40:19.170
And it would
not be just for numbers; generic types would

00:40:19.170 --> 00:40:23.540
be good for coding hash sets, for example,
and there are many other uses.

00:40:23.540 --> 00:40:26.999
And each user would not have to code up such
number classes, each for his own use.

00:40:26.999 --> 00:40:32.460
When a language gives you the right tools,
such classes can be coded by a few and then

00:40:32.460 --> 00:40:37.070
put up as libraries for other users to use,
or not, as they choose; but they don’t have

00:40:37.070 --> 00:40:40.989
to
be built in as part of the base language.

00:40:40.989 --> 00:40:44.859
If you give a person a fish, he can eat for
a day.

00:40:44.859 --> 00:40:49.580
If you teach a person to fish, he can eat
his whole life long.

00:40:49.580 --> 00:40:54.390
If you give a person tools, he can make a
fishing pole—and lots of other tools!

00:40:54.390 --> 00:40:57.440
He can
build a machine to crank out fishing poles.

00:40:57.440 --> 00:41:07.769
In this way he can help other persons to catch
fish.

00:41:07.769 --> 00:41:12.809
Meta means that you step back from your own
place.

00:41:12.809 --> 00:41:16.720
What you used to do is now what
you see.

00:41:16.720 --> 00:41:20.380
What you were is now what you act on.

00:41:20.380 --> 00:41:23.170
Verbs turn to nouns.

00:41:23.170 --> 00:41:25.890
What you used
to think of as a pattern is now treated as

00:41:25.890 --> 00:41:30.279
a thing to put in the slot of an other pattern.

00:41:30.279 --> 00:41:38.299
A meta foo is a foo in whose slots you can
put parts of a foo.

00:41:38.299 --> 00:41:43.490
In a way, a language design of the old school
is a pattern for programs.

00:41:43.490 --> 00:41:45.979
But now we
need to 'go meta.'

00:41:45.979 --> 00:41:49.390
We should now think of a language design as
a pattern for language

00:41:49.390 --> 00:41:53.529
designs, a tool for making more tools of the
same kind.

00:41:53.529 --> 00:41:57.589
This is the nub of what I want to say.

00:41:57.589 --> 00:42:01.220
A language design can no longer be a thing.

00:42:01.220 --> 00:42:04.579
It
must be a pattern—a pattern for growth—a

00:42:04.579 --> 00:42:08.839
pattern for growing the pattern for defining
the patterns that programmers can use for

00:42:08.839 --> 00:42:11.069
their real work and their main goal.

00:42:11.069 --> 00:42:16.200
My point is that a good programmer in these
times does not just write programs.

00:42:16.200 --> 00:42:19.589
A good programmer builds a working vocabulary.

00:42:19.589 --> 00:42:23.029
In other words, a good programmer
does language design, though not from scratch,

00:42:23.029 --> 00:42:28.710
but by building on the frame of a base
language.

00:42:28.710 --> 00:42:32.650
In the course of giving this talk, because
I started with a small language, I have had

00:42:32.650 --> 00:42:38.901
to define fifty or more new words or phrases
and sixteen names of persons or things; and

00:42:38.901 --> 00:42:42.829
I laid out six rules for making new words
from old ones.

00:42:42.829 --> 00:42:46.380
In this way I added to the base
language.

00:42:46.380 --> 00:42:50.670
If I were to write a book by starting from
just the words of one syllable, I am

00:42:50.670 --> 00:42:54.440
sure that I would have to define hundreds
of new words.

00:42:54.440 --> 00:42:57.520
It should give no one pause to
note that the writing of a program a million

00:42:57.520 --> 00:43:03.750
lines of code in length might need many, many
hundreds of new words—that is to say, a

00:43:03.750 --> 00:43:07.390
new language built up on the base language.

00:43:07.390 --> 00:43:10.690
I will
be so bold as to say that it can be done in

00:43:10.690 --> 00:43:12.400
no other way.

00:43:12.400 --> 00:43:17.950
Well— there may be one other
way, which is to use a large, rich programming

00:43:17.950 --> 00:43:22.410
language that has grown over
tens or hundreds of years, that has all we

00:43:22.410 --> 00:43:28.319
need to say what we want to say, that we are
taught as we grow up and take for granted.

00:43:28.319 --> 00:43:32.089
It may be that a hundred years from now
there will be a programming language that

00:43:32.089 --> 00:43:34.630
by then has stood the test of time, needs
no

00:43:34.630 --> 00:43:38.589
more changes for most uses, and is used by
all persons who write programs because each

00:43:38.589 --> 00:43:41.200
child learns it in school.

00:43:41.200 --> 00:43:44.520
But that is not where we are now.

00:43:44.520 --> 00:43:46.869
So.

00:43:46.869 --> 00:43:51.599
Language design is not at all the same kind
of work it was thirty years ago, or

00:43:51.599 --> 00:43:54.460
twenty years ago.

00:43:54.460 --> 00:43:56.779
Back then, you could set out to design a whole
language and then build

00:43:56.779 --> 00:44:02.250
it by your own self, or with a small team,
because it was small and because what you

00:44:02.250 --> 00:44:04.979
would then do with it was small.

00:44:04.979 --> 00:44:07.700
Now programs are big messes with many needs.

00:44:07.700 --> 00:44:10.920
A small language won’t do the job.

00:44:10.920 --> 00:44:15.450
If you design a big language all at once and
then try to build it all at once, it will

00:44:15.450 --> 00:44:18.160
fail.

00:44:18.160 --> 00:44:22.470
You will end up late and some other small
language will take your place.

00:44:22.470 --> 00:44:25.039
It would be
great if there were some small programming

00:44:25.039 --> 00:44:29.970
language that felt large, the way Basic English
is small but feels large in some ways.

00:44:29.970 --> 00:44:32.900
But I don’t know how to do it and I have
good cause

00:44:32.900 --> 00:44:34.569
to doubt that it can be done at all.

00:44:34.569 --> 00:44:40.299
In its day, APL was a small language that
felt large;

00:44:40.299 --> 00:44:45.829
but our needs have grown and APL did not have
a good pattern for growth.

00:44:45.829 --> 00:44:52.819
So I think the sole way to win is to plan
for growth.

00:44:52.819 --> 00:44:58.569
To plan for growth with help from
users.

00:44:58.569 --> 00:45:00.729
This is a win for you because you have help.

00:45:00.729 --> 00:45:05.589
This is a win for the users because they get
to have their say and get to bend the growth

00:45:05.589 --> 00:45:07.039
to their needs.

00:45:07.039 --> 00:45:11.140
But you need to have one or
more persons, too, or one or more groups,

00:45:11.140 --> 00:45:13.680
to take on the task of judging and testing
and

00:45:13.680 --> 00:45:18.089
sifting what the users do and say, and adding
what they think best to the big pile of

00:45:18.089 --> 00:45:23.289
code, in the hope that other users will trust
what they say and not have to go to all the

00:45:23.289 --> 00:45:28.580
work to test and judge and sift each new claim
or each new piece of code, each for his own

00:45:28.580 --> 00:45:30.690
self.

00:45:30.690 --> 00:45:36.599
Parts of the language must be designed to
help the task of growth- of growing the

00:45:36.599 --> 00:45:37.710
language.

00:45:37.710 --> 00:45:42.140
A good set of types, ways for a user to define
new types, to add new words and

00:45:42.140 --> 00:45:48.539
new rules to the language, to define and use
all sorts of patterns—all these are needed.

00:45:48.539 --> 00:45:52.640
The designer should not, for example, define
twenty kinds of number types in the language.

00:45:52.640 --> 00:46:00.290
But there will be users who, all told, beg
for twenty different kinds of numbers.

00:46:00.290 --> 00:46:03.609
Different.

00:46:03.609 --> 00:46:06.239
Beg for twenty kinds of numbers.

00:46:06.239 --> 00:46:10.190
This is hard.

00:46:10.190 --> 00:46:14.309
The language should have a way for the user
to define number types that work well with

00:46:14.309 --> 00:46:20.849
each other, and with plus signs and other
such signs, and with the many ways of pushing

00:46:20.849 --> 00:46:23.559
bits in and out of the computer.

00:46:23.559 --> 00:46:25.690
One might define just one or two number types
at the

00:46:25.690 --> 00:46:28.049
start, to show how it ought to be done.

00:46:28.049 --> 00:46:31.260
Then leave the rest to the users.

00:46:31.260 --> 00:46:34.650
Help them all as
best you can to work side by side- and not

00:46:34.650 --> 00:46:41.029
nose to nose.

00:46:41.029 --> 00:46:46.109
You may find that you need to add warts as
part of the design, so that you can get it

00:46:46.109 --> 00:46:50.910
out the door fast, with the goal of taking
out the warts at a later time.

00:46:50.910 --> 00:46:54.490
Now, there are
warts and then there are warts!

00:46:54.490 --> 00:46:57.799
With care, one can design a wart so that it
will not be

00:46:57.799 --> 00:47:00.910
too hard to take out or patch up later on.

00:47:00.910 --> 00:47:02.339
But if you do not take care at the start,
you

00:47:02.339 --> 00:47:07.329
may be stuck for years to come with a wart
you did not plan.

00:47:07.329 --> 00:47:11.529
Some warts are not bad things you put in,
but good things you leave out.

00:47:11.529 --> 00:47:13.759
Have a plan
to add those good things at a later time,

00:47:13.759 --> 00:47:17.470
if you should choose to do so, and make sure
that other parts of your design don’t cut

00:47:17.470 --> 00:47:19.829
you off from adding those good things when
the

00:47:19.829 --> 00:47:22.819
time is right.

00:47:22.819 --> 00:47:26.690
I hope to bring these thoughts to bear on
the Java programming language.

00:47:26.690 --> 00:47:29.069
The Java
programming language has done as well as it

00:47:29.069 --> 00:47:33.549
has up to now because it started small- I
think.

00:47:33.549 --> 00:47:37.140
It was not hard to learn and it was not hard
to port.

00:47:37.140 --> 00:47:40.960
It has grown quite a bit
since then.

00:47:40.960 --> 00:47:45.249
If the design of the Java programming language
as it is now had been put forth

00:47:45.249 --> 00:47:49.989
three years ago, it would have failed— of
that I am sure.

00:47:49.989 --> 00:47:51.559
Programmers would have cried,
'Too big!

00:47:51.559 --> 00:47:52.559
Too much hair!

00:47:52.559 --> 00:47:54.890
I can’t deal with all that!'

00:47:54.890 --> 00:47:58.380
But in real life it has worked out
fine because the users have grown with the

00:47:58.380 --> 00:48:01.670
language and learned it piece by piece, and
they buy in to it because they have had some

00:48:01.670 --> 00:48:05.779
say in how to change the language.

00:48:05.779 --> 00:48:09.369
And the Java programming language needs to
grow yet some more—but, I hope, not a lot

00:48:09.369 --> 00:48:10.430
more.

00:48:10.430 --> 00:48:16.309
At least, I think only a few more rules are
needed—the rest can be done with libraries,

00:48:16.309 --> 00:48:25.910
most of them built by users and not by Sun.

00:48:25.910 --> 00:48:30.559
If we add hundreds of new things to the Java
brand programming language, we will have

00:48:30.559 --> 00:48:34.469
a huge language, but it will take a long time
to get there.

00:48:34.469 --> 00:48:40.789
But if we add a few
things— just the right things- generic types,

00:48:40.789 --> 00:48:44.420
operator overloading, user defined types of
light weight, for use as numbers and small

00:48:44.420 --> 00:48:47.890
vectors and such— and some other things-
that

00:48:47.890 --> 00:48:53.069
are designed to let users make and add things
for their own use, I think we can go a long

00:48:53.069 --> 00:48:55.269
way, and much faster.

00:48:55.269 --> 00:48:59.650
We need to put tools for language growth in
the hands of the users.

00:48:59.650 --> 00:49:02.941
I hope that we can, in this way or some other
way, design a programming language

00:49:02.941 --> 00:49:07.369
where we don’t seem to spend most of our
time talking and writing in words of just

00:49:07.369 --> 00:49:09.960
one
syllable.

00:49:09.960 --> 00:49:17.599
One of the good things I can say for short
words is that they make for short talks.

00:49:17.599 --> 00:49:22.660
They gave me an hour and a half for this talk,
and I have used less than an hour.

00:49:22.660 --> 00:49:24.349
Once
I am done you will have time to go out in

00:49:24.349 --> 00:49:27.390
the hall, have a cup of tea and talk with
your

00:49:27.390 --> 00:49:32.160
friends.

00:49:32.160 --> 00:49:35.289
But first I would like to tell you what I
have learned from the task of designing this

00:49:35.289 --> 00:49:37.589
talk.

00:49:37.589 --> 00:49:41.539
In choosing to give up the many long words
that I have come to know since I was a

00:49:41.539 --> 00:49:46.079
child, words that have many fine shades of
meaning, I made this task much harder than

00:49:46.079 --> 00:49:48.329
it
needs to be.

00:49:48.329 --> 00:49:51.760
I hope that you have not found it too hard
on your ears.

00:49:51.760 --> 00:49:57.779
But I found that
sticking to this rule made me think.

00:49:57.779 --> 00:50:00.049
I had to take time to think through how to
phrase

00:50:00.049 --> 00:50:01.710
each thought.

00:50:01.710 --> 00:50:06.180
And there was this choice for each new word:
is it worth the work to define

00:50:06.180 --> 00:50:10.089
it, or should I just stick with the words
I have?

00:50:10.089 --> 00:50:14.950
Should I do the work of defining a new
word such as mirror, or should I just say

00:50:14.950 --> 00:50:16.710
'looking glass' each time I want to speak
of

00:50:16.710 --> 00:50:18.300
one?

00:50:18.300 --> 00:50:23.420
As an example, I was tempted more than once
to state the 'ly' rule for making new words

00:50:23.420 --> 00:50:28.309
that change what verbs mean, but in the end
I chose to cast all such words to one side

00:50:28.309 --> 00:50:30.270
and
make do.

00:50:30.270 --> 00:50:35.671
And I came that close to defining the word
without, but each time, for better or

00:50:35.671 --> 00:50:38.979
for worse, I found some other way to phrase
my thought.

00:50:38.979 --> 00:50:43.660
I learned in my youth, from the books of such
great teachers of writing as Strunk and

00:50:43.660 --> 00:50:48.319
White, that it is better to choose short words
when I can.

00:50:48.319 --> 00:50:51.880
I should not choose long,
hard words just to make other persons think

00:50:51.880 --> 00:50:53.839
that I know a lot.

00:50:53.839 --> 00:50:58.160
I should try to make my
thoughts clear; if they are clear and right,

00:50:58.160 --> 00:51:02.470
then other persons can judge my work as it
ought to be judged.

00:51:02.470 --> 00:51:06.220
And I'm sure you will.

00:51:06.220 --> 00:51:10.030
From the work of planning this talk, in which
I have tried to go with this rule- of short

00:51:10.030 --> 00:51:17.140
words- much farther than in the past, I found
that for the most part they were right.

00:51:17.140 --> 00:51:21.900
Short words work well, if we choose them well.

00:51:21.900 --> 00:51:27.869
Thus I think that programming languages need
to be more like the languages we

00:51:27.869 --> 00:51:33.769
speak— but it might be good, too, if we
were to use the languages we speak more in

00:51:33.769 --> 00:51:36.990
the
way that we now use programming languages.

00:51:36.990 --> 00:51:41.969
All in all, I think it might be a good thing
if those who rule our lives—those in high

00:51:41.969 --> 00:51:46.940
places who do the work of state, those who
judge what we do, and most of all those who

00:51:46.940 --> 00:51:51.349
make the laws—were made to define their
terms and to say all else that they say in

00:51:51.349 --> 00:52:03.640
words
of one syllable.

00:52:03.640 --> 00:52:12.200
For I have found that this mode of speech
makes it hard to hedge.

00:52:12.200 --> 00:52:15.319
It takes
work, and great care, and some skill, to find

00:52:15.319 --> 00:52:19.859
just the right way to say what you want to
say, but in the end you seem to have no choice

00:52:19.859 --> 00:52:21.660
but to talk straight.

00:52:21.660 --> 00:52:24.720
If you do not veer
wide of the truth, you are forced to hit it

00:52:24.720 --> 00:52:25.720
dead on.

00:52:25.720 --> 00:52:43.460
I urge you, too, to give it a try.

00:52:43.460 --> 00:53:14.369
Thank you.

