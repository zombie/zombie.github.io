WEBVTT
Kind: captions
Language: en

00:00:04.240 --> 00:00:16.400
All right, who's ready for some more category&nbsp;
theory? You're all in the wrong room.

00:00:16.400 --> 00:00:26.080
So this talk I hope seems deceptively obvious. One&nbsp;
of the things that's great about this conferences,&nbsp;&nbsp;

00:00:26.800 --> 00:00:30.400
this is a pretty cutting edge crowd. A lot of&nbsp;
you are adopting new technologies. A lot of you&nbsp;&nbsp;

00:00:30.400 --> 00:00:35.680
are doing functional programming and you may, you&nbsp;
may be nodding saying, yeah, yeah, yeah through&nbsp;&nbsp;

00:00:35.680 --> 00:00:42.560
parts of this. And if some of it's familiar then&nbsp;
that's great. On the other hand, I think that&nbsp;&nbsp;

00:00:43.200 --> 00:00:46.560
I would hope that you would come away from&nbsp;
this talk with some tools you could use&nbsp;&nbsp;

00:00:47.520 --> 00:00:51.520
to help conduct a similar kind&nbsp;
of discussion to this talk&nbsp;&nbsp;

00:00:51.520 --> 00:00:54.960
with other people that you're trying&nbsp;
to convince to do the right thing.

00:00:58.240 --> 00:01:05.360
So I'll start with an appeal to authority.&nbsp;
"Simplicity is a prerequisite for reliability."&nbsp;&nbsp;

00:01:05.360 --> 00:01:09.840
I certainly agree with this. I don't agree&nbsp;
with everything Dijkstra said and I, and I&nbsp;&nbsp;

00:01:09.840 --> 00:01:15.200
think he might've been very wrong about proof in&nbsp;
particular, but I think he's right about this.&nbsp;&nbsp;

00:01:17.200 --> 00:01:20.320
We need to build simple systems&nbsp;
if we want to build good systems.&nbsp;&nbsp;

00:01:21.040 --> 00:01:23.120
And I don't think we focus on enough on that.

00:01:24.640 --> 00:01:29.200
I love word origins. They are tremendous&nbsp;
fun. One of the, the reasons why they're&nbsp;&nbsp;

00:01:29.200 --> 00:01:34.880
fun is because words eventually become come&nbsp;
to mean whatever we all accept them to mean,&nbsp;&nbsp;

00:01:34.880 --> 00:01:37.440
you know, whatever's commonly understood&nbsp;
to be the meaning is what it means.

00:01:38.720 --> 00:01:42.720
And it's often interesting to say, well, I wish I&nbsp;
could, I wish we'd go back to what it really means&nbsp;&nbsp;

00:01:43.520 --> 00:01:46.800
and use that. And I think there's a couple&nbsp;
of words that I'm going to use in this talk&nbsp;&nbsp;

00:01:46.800 --> 00:01:51.600
that I would love for you to come away&nbsp;
knowing the origins of, and try to use&nbsp;&nbsp;

00:01:51.600 --> 00:01:54.720
more precisely, especially&nbsp;
when talking about software.

00:01:56.640 --> 00:02:02.640
So the first word is "simple". And the roots&nbsp;
of this word are "sim" and "plex", and that&nbsp;&nbsp;

00:02:02.640 --> 00:02:14.480
means one fold or one braid or twist. And that&nbsp;
characteristic about being about one literally&nbsp;&nbsp;

00:02:14.480 --> 00:02:20.800
fold or twist, of course, one twist, Hey, what's&nbsp;
one twist look like? No twists, right? Actually.&nbsp;&nbsp;

00:02:22.080 --> 00:02:29.200
And it, the opposite of this word is complex,&nbsp;
which means braided together or folded together.

00:02:31.280 --> 00:02:34.400
Being able to think about software in terms of&nbsp;
whether or not it's folded together, is sort of&nbsp;&nbsp;

00:02:34.400 --> 00:02:41.440
the central point of this talk. The other word&nbsp;
we frequently use interchangeably with "simple"&nbsp;&nbsp;

00:02:41.440 --> 00:02:47.360
is the word "easy". And the derivation there is&nbsp;
through a French word, and the last step of the&nbsp;&nbsp;

00:02:47.360 --> 00:02:52.320
derivation is actually speculative but I bought&nbsp;
it because it serves this talk really well.&nbsp;&nbsp;

00:02:54.000 --> 00:03:00.080
And that is from the Latin word that is the&nbsp;
root of "adjacent", and which means to lie near&nbsp;&nbsp;

00:03:00.720 --> 00:03:05.520
and to be nearby. And the opposite is "hard".&nbsp;
Of course, the root of hard has nothing to do&nbsp;&nbsp;

00:03:05.520 --> 00:03:14.080
with lying near. It doesn't mean lie far away.&nbsp;
It actually means like strong or tortuously so.

00:03:16.960 --> 00:03:20.080
So if we want to try to apply simple&nbsp;
to the kinds of work that we do&nbsp;&nbsp;

00:03:21.520 --> 00:03:24.320
we're going to start with this&nbsp;
concept of having one braid&nbsp;&nbsp;

00:03:25.680 --> 00:03:29.920
and look at it in a few different dimensions.&nbsp;
I thought it was interesting in Eric's&nbsp;&nbsp;

00:03:29.920 --> 00:03:33.120
talk to talk about dimensions because it's&nbsp;
definitely a big part of doing design work.

00:03:34.080 --> 00:03:37.520
And so if we want to look for simple things,&nbsp;
we want to look for things that have sort of&nbsp;&nbsp;

00:03:37.520 --> 00:03:40.400
one of something they do, they have one role,&nbsp;&nbsp;

00:03:41.280 --> 00:03:46.400
they fulfill one task or job they're&nbsp;
about accomplishing sort of one objective.&nbsp;&nbsp;

00:03:47.600 --> 00:03:57.680
They might be about one concept like security&nbsp;
and sort of overlapping with that as they may,&nbsp;&nbsp;

00:03:57.680 --> 00:04:01.200
they may be about a particular dimension&nbsp;
of the problem that you're trying to solve.

00:04:02.000 --> 00:04:05.280
The critical thing there though, is that when&nbsp;
you're looking for something that's simple,&nbsp;&nbsp;

00:04:05.280 --> 00:04:08.000
you want to see it have focus in these areas.&nbsp;&nbsp;

00:04:08.880 --> 00:04:15.120
You don't want to see it combining things. On the&nbsp;
other hand, we can't get too fixated about one.&nbsp;&nbsp;

00:04:15.920 --> 00:04:19.840
In particular simple doesn't mean&nbsp;
that there's only one of them.

00:04:20.880 --> 00:04:25.600
Right. It also doesn't mean an&nbsp;
interface that only has one operation.&nbsp;&nbsp;

00:04:26.640 --> 00:04:28.320
So it's important to distinguish&nbsp;&nbsp;

00:04:31.520 --> 00:04:38.240
cardinality, right? Counting things from actual&nbsp;
interleaving what matters for simplicity is that&nbsp;&nbsp;

00:04:38.240 --> 00:04:45.040
there's there's no, interleaving not that there's&nbsp;
only one thing. And that's very important.

00:04:47.840 --> 00:04:54.640
Okay. The other critical thing about simple&nbsp;
as we've just described it is if something is&nbsp;&nbsp;

00:04:54.640 --> 00:05:02.080
interleaved or not that's sort of an objective&nbsp;
thing. We can probably go and look and see,&nbsp;&nbsp;

00:05:02.080 --> 00:05:05.680
I don't see any connections. I don't see&nbsp;
anywhere where this twists with something else.&nbsp;&nbsp;

00:05:06.400 --> 00:05:09.840
So simple is actually an objective notion.

00:05:11.120 --> 00:05:14.560
That's also very important in deciding&nbsp;
the difference between simple, easy.&nbsp;&nbsp;

00:05:16.560 --> 00:05:21.200
So let's look at easy. I think&nbsp;
this notion of nearness is really,&nbsp;&nbsp;

00:05:21.200 --> 00:05:26.960
really cool. In particular obviously there's&nbsp;
many ways in which something can be near, right.&nbsp;&nbsp;

00:05:26.960 --> 00:05:33.760
The sort of the physical notion of it being near&nbsp;
right, is something you know, like right there.

00:05:33.760 --> 00:05:38.160
And I think that's where the root of the word came&nbsp;
from. You know, this is easy to obtain cause it's,&nbsp;&nbsp;

00:05:38.160 --> 00:05:40.800
it's nearby. It's not in the next&nbsp;
town. I don't have to take a horse or&nbsp;&nbsp;

00:05:41.360 --> 00:05:45.920
whatever to go get to it. We don't have the same&nbsp;
notion of physicality necessarily in our software.&nbsp;&nbsp;

00:05:46.480 --> 00:05:50.320
But we do sort of have our own&nbsp;
hard drive or our own tool.

00:05:51.360 --> 00:05:55.520
Or sort of the ability to make things&nbsp;
physically near by getting them through&nbsp;&nbsp;

00:05:55.520 --> 00:06:01.840
things like installers and stuff like that. The&nbsp;
second notion of nearness is something being near&nbsp;&nbsp;

00:06:01.840 --> 00:06:09.920
to our understanding, right. Or in our current&nbsp;
skillset. And I don't mean in this case near to&nbsp;&nbsp;

00:06:09.920 --> 00:06:14.560
our understanding, meaning a capability, I mean,&nbsp;
literally near something that we already know.

00:06:15.440 --> 00:06:19.840
So the word, the word in this&nbsp;
case is, is about being familiar.&nbsp;&nbsp;

00:06:21.360 --> 00:06:28.080
I think that collectively we are infatuated&nbsp;
with these two notions of easy. We are just so&nbsp;&nbsp;

00:06:29.200 --> 00:06:34.320
self-involved in these two aspects&nbsp;
it's hurting us tremendously.&nbsp;&nbsp;

00:06:34.320 --> 00:06:38.080
All we care about is, you know, can I get this&nbsp;
instantly and start running it in five seconds?

00:06:38.720 --> 00:06:42.960
It could be this giant hairball that you&nbsp;
got, but all you care is "can you get it?".&nbsp;&nbsp;

00:06:44.560 --> 00:06:48.480
In addition, we're fixated on,&nbsp;
oh, I can't, I can't read that.&nbsp;&nbsp;

00:06:51.040 --> 00:06:56.720
I can't read German. Does that mean German&nbsp;
is unreadable? No, I don't know German.&nbsp;&nbsp;

00:06:58.720 --> 00:07:03.040
So you know, this, this sort of&nbsp;
approach is, is definitely not helpful.

00:07:03.040 --> 00:07:07.040
In particular, if you want everything to&nbsp;
be familiar, you will never learn anything&nbsp;&nbsp;

00:07:07.040 --> 00:07:10.240
new because it can't be significantly&nbsp;
different from what you already know&nbsp;&nbsp;

00:07:10.240 --> 00:07:12.480
and not drift away from the familiarity.

00:07:13.920 --> 00:07:20.000
There's a third aspect of being easy that&nbsp;
I don't think we think enough about. That's&nbsp;&nbsp;

00:07:20.000 --> 00:07:25.280
going to become critical to this discussion, which&nbsp;
is, which now is being near to our capabilities.

00:07:26.320 --> 00:07:30.160
And we don't like to talk about this because&nbsp;
it makes us uncomfortable because what kind of&nbsp;&nbsp;

00:07:30.160 --> 00:07:34.400
capabilities are we're talking about? Like, if&nbsp;
we're talking about easy in the case of violin&nbsp;&nbsp;

00:07:34.400 --> 00:07:40.640
playing or piano playing or mountain climbing&nbsp;
or something like that. Well, you know, I don't&nbsp;&nbsp;

00:07:40.640 --> 00:07:44.880
personally feel bad if I don't play the violin&nbsp;
well, because I don't play the violin at all.

00:07:46.560 --> 00:07:50.880
But the work that we're in is conceptual&nbsp;
work. So when we talked, start talking about&nbsp;&nbsp;

00:07:50.880 --> 00:07:55.680
something being outside of our capability&nbsp;
well, you know, it really starts trampling&nbsp;&nbsp;

00:07:55.680 --> 00:08:02.480
on our, our egos in a big way. And so,&nbsp;
you know, due to a combination of hubris&nbsp;&nbsp;

00:08:02.480 --> 00:08:07.680
and insecurity we never really talk about whether&nbsp;
or not something is outside of our capabilities.

00:08:07.680 --> 00:08:15.440
It ends up that it's not so embarrassing after&nbsp;
all, because we don't have tremendously divergent&nbsp;&nbsp;

00:08:15.440 --> 00:08:19.920
abilities in that area. The last&nbsp;
thing I want to say about easy&nbsp;&nbsp;

00:08:20.480 --> 00:08:24.640
and the critical thing to distinguish&nbsp;
it from simple is that easy is relative,&nbsp;&nbsp;

00:08:25.520 --> 00:08:29.120
right? Playing the violin and reading&nbsp;
German are really hard for me.

00:08:30.080 --> 00:08:35.600
They're easy for other people, certain other&nbsp;
people. So unlike simple, where we can go and&nbsp;&nbsp;

00:08:35.600 --> 00:08:40.080
look for interleaving, look for braiding. Easy&nbsp;
is always going to be, you know, easy for whom&nbsp;&nbsp;

00:08:41.200 --> 00:08:46.640
or hard for whom. It's a relative term. The&nbsp;
fact that we throw these things around sort&nbsp;&nbsp;

00:08:46.640 --> 00:08:49.600
of casually saying, oh, I like to use&nbsp;
that technology because it's simple.

00:08:49.600 --> 00:08:53.760
And when I'm saying simple, I mean easy. And&nbsp;
when I'm saying easy, I mean, because I already&nbsp;&nbsp;

00:08:53.760 --> 00:08:58.000
know something that looks very much a like,&nbsp;
that is how this whole thing degrades, and we&nbsp;&nbsp;

00:08:58.000 --> 00:09:06.000
can never have an objective discussion about the&nbsp;
qualities that matter to us in our software. So&nbsp;&nbsp;

00:09:07.040 --> 00:09:12.560
what's one critical area where we, where&nbsp;
we have to distinguish these two things and&nbsp;&nbsp;

00:09:14.480 --> 00:09:18.480
and look at them from a perspective&nbsp;
of them being easy and being simple?

00:09:19.360 --> 00:09:21.840
It is, it has to do with constructs and artifacts,&nbsp;&nbsp;

00:09:22.480 --> 00:09:27.040
right? We program with constructs, we have&nbsp;
programming languages, we use particular libraries&nbsp;&nbsp;

00:09:27.040 --> 00:09:32.800
and those things in and of themselves when we&nbsp;
look at them, like when we look at the code,&nbsp;&nbsp;

00:09:32.800 --> 00:09:39.040
we've right have certain characteristics in and&nbsp;
of themselves, but we're in a business of art.

00:09:39.760 --> 00:09:44.640
Right. We don't ship source code and the user&nbsp;
doesn't look at our source code and say, okay, oh,&nbsp;&nbsp;

00:09:44.640 --> 00:09:50.800
that's so pleasant, right? No, they run&nbsp;
our software and they run it for a long&nbsp;&nbsp;

00:09:50.800 --> 00:09:55.200
period of time. And over time we keep&nbsp;
glomming more stuff on our software,&nbsp;&nbsp;

00:09:56.000 --> 00:10:00.000
all that stuff, stuff, the running&nbsp;
of it. The performance of it,&nbsp;&nbsp;

00:10:00.000 --> 00:10:06.240
the ability to change it all is an attribute&nbsp;
of the artifact, not the original construct.

00:10:07.280 --> 00:10:14.000
But again, here, we still focus so much on our&nbsp;
experience of the use of the construct. Look,&nbsp;&nbsp;

00:10:14.000 --> 00:10:20.320
I only had to type 16 characters. Wow. That's&nbsp;
great. No semicolon or things like that.&nbsp;&nbsp;

00:10:21.360 --> 00:10:24.560
This whole notion of sort of&nbsp;
programmer convenience. Again,&nbsp;&nbsp;

00:10:24.560 --> 00:10:28.480
we are infatuated with it.&nbsp;
Not, not to our benefit.

00:10:29.360 --> 00:10:35.600
On the flip side, it gets even worse. Our&nbsp;
employers are also infatuated with it, right.&nbsp;&nbsp;

00:10:35.600 --> 00:10:41.440
Those first two meanings of easy. What do they&nbsp;
mean. Right. If I can get another programmer in&nbsp;&nbsp;

00:10:41.440 --> 00:10:51.200
here. Right. And they look at your source code and&nbsp;
they think it's familiar. Right. And they already&nbsp;&nbsp;

00:10:51.200 --> 00:10:55.440
know the toolkit, right. So it's near, at hand.&nbsp;
They've always had the same tool in their toolkit.

00:10:55.440 --> 00:11:00.240
They can read it. I can replace you.&nbsp;
It's a breeze, especially if I ignore&nbsp;&nbsp;

00:11:00.240 --> 00:11:04.880
the third notion of easy. Which is whether&nbsp;
or not anybody could understand your code.&nbsp;&nbsp;

00:11:05.760 --> 00:11:08.960
Right. Because they don't actually care about&nbsp;
that. They just care if somebody can go sit in&nbsp;&nbsp;

00:11:08.960 --> 00:11:16.160
your seat, start typing. So again, as sort&nbsp;
of a business owners this sort of again,&nbsp;&nbsp;

00:11:16.160 --> 00:11:20.640
the same kind of focus on those first two aspects&nbsp;
of easy, cause it makes programmers replaceable.

00:11:21.680 --> 00:11:25.600
So we're going to see, we're going to contrast&nbsp;
this with the impacts of long-term use.&nbsp;&nbsp;

00:11:26.560 --> 00:11:33.280
Right. What does it mean to use this&nbsp;
long-term and uh, yeah, what what's there,&nbsp;&nbsp;

00:11:33.280 --> 00:11:37.200
what's there as all the meat, right? Does&nbsp;
the software do what it's supposed to do?&nbsp;&nbsp;

00:11:39.520 --> 00:11:42.640
Is it of high quality? Can we rely&nbsp;
on it doing what it's supposed to do?

00:11:43.200 --> 00:11:48.400
Can we fix problems when they arise?&nbsp;
And if we're given a new requirement,&nbsp;&nbsp;

00:11:48.400 --> 00:11:54.240
can we change it? These things have nothing&nbsp;
to do with the construct as we typed it in&nbsp;&nbsp;

00:11:54.880 --> 00:12:00.160
or very little to do with it and have a lot&nbsp;
to do with the attributes of the artifact.&nbsp;&nbsp;

00:12:01.520 --> 00:12:06.400
We have to start assessing our&nbsp;
constructs based around the artifacts,&nbsp;&nbsp;

00:12:06.400 --> 00:12:12.480
not around the look and feel of the experience&nbsp;
of typing it in or the cultural aspects of that.

00:12:13.600 --> 00:12:17.360
So let's talk a little about bit&nbsp;
about limits. Oh, look, it does move.&nbsp;&nbsp;

00:12:19.280 --> 00:12:24.240
This is just supposed to sort of lull you into&nbsp;
this state where everything I say seems true&nbsp;&nbsp;

00:12:27.120 --> 00:12:29.200
because I can't use monads to do that.

00:12:35.520 --> 00:12:40.000
This stuff is pretty simple logic, right? How&nbsp;
can we possibly make things that are reliable&nbsp;&nbsp;

00:12:40.000 --> 00:12:48.240
that we don't understand? Right. It's very, very&nbsp;
difficult. I think Professor Sussman made a great&nbsp;&nbsp;

00:12:48.240 --> 00:12:53.120
point saying there's going to be this trade-off&nbsp;
right. As we make things more flexible and&nbsp;&nbsp;

00:12:53.120 --> 00:12:58.640
extensible and dynamic in some possible futures&nbsp;
for some kinds of systems we are going to make&nbsp;&nbsp;

00:12:58.640 --> 00:13:05.840
a trade-off in our ability to, to understand their&nbsp;
their behavior and make sure that they're correct.

00:13:06.400 --> 00:13:11.200
But for the things that we want to understand and&nbsp;
make sure are correct, we're going to be limited.&nbsp;&nbsp;

00:13:12.640 --> 00:13:15.840
We're going to be limited in our understanding&nbsp;
and our understanding is very limited,&nbsp;&nbsp;

00:13:15.840 --> 00:13:18.480
right? There's the whole notion of, you&nbsp;
know, how many, how many balls can you&nbsp;&nbsp;

00:13:18.480 --> 00:13:21.440
keep in the air at the time? Or how many&nbsp;
things can you keep in mind at a time?

00:13:21.440 --> 00:13:25.520
It's a, it's a limited number and it's a very&nbsp;
small number . Right. So we can only consider&nbsp;&nbsp;

00:13:25.520 --> 00:13:30.560
a few things. And when things are intertwined&nbsp;
together, we lose the ability to take them in&nbsp;&nbsp;

00:13:30.560 --> 00:13:36.720
isolation. So if every time I think I pull out&nbsp;
a new part of the software I need to comprehend&nbsp;&nbsp;

00:13:36.720 --> 00:13:40.400
and it's attached to another thing I had to&nbsp;
pull that other thing into my mind because I&nbsp;&nbsp;

00:13:40.400 --> 00:13:44.880
can't think about the one without the other.&nbsp;
That's the nature of them being intertwined.&nbsp;&nbsp;

00:13:44.880 --> 00:13:52.080
So every intertwining is adding this burden and&nbsp;
the burden is kind of combinatorial as to the&nbsp;&nbsp;

00:13:52.080 --> 00:13:57.840
number of things that we can, we can consider. So&nbsp;
fundamentally this complexity and by complexity,&nbsp;&nbsp;

00:13:57.840 --> 00:14:02.480
I mean this braiding together of things is&nbsp;
going to limit our ability to understand our

00:14:04.640 --> 00:14:14.800
So so how do we change our software? Apparently&nbsp;
I heard in the talk today that agile and extreme&nbsp;&nbsp;

00:14:14.800 --> 00:14:20.320
programming have shown that refactoring and&nbsp;
tests allow us to make a change with zero.

00:14:23.440 --> 00:14:27.360
I never knew that. I still do not know that&nbsp;&nbsp;

00:14:27.920 --> 00:14:32.800
because that's not actually a&nbsp;
knowable thing. It's, that's phooey,

00:14:36.160 --> 00:14:38.800
If you're going to change software,&nbsp;
you're going to need to analyze&nbsp;&nbsp;

00:14:38.800 --> 00:14:42.160
what it does and make decisions about&nbsp;
what it ought to do. You know, I mean,&nbsp;&nbsp;

00:14:42.160 --> 00:14:46.080
at least you're going to have to go and say,&nbsp;
what is the impact of this potential change,&nbsp;&nbsp;

00:14:46.800 --> 00:14:52.320
right. And what parts of the software do&nbsp;
I need to go to, to affect the change?

00:14:54.160 --> 00:14:59.200
And you know, I don't, I don't care if we're using&nbsp;
XP or Agile or anything else you're not going to&nbsp;&nbsp;

00:14:59.200 --> 00:15:03.760
get around the fact that if you can't reason about&nbsp;
your program, you can't make these decisions.&nbsp;&nbsp;

00:15:06.160 --> 00:15:09.360
But I do want to make clear here because a lot&nbsp;
of people, as soon as they hear the word reason&nbsp;&nbsp;

00:15:09.360 --> 00:15:13.360
about they're like, oh my God, are you saying&nbsp;
that you have to be able to prove programs?

00:15:13.360 --> 00:15:16.480
I am not. I don't believe in that.&nbsp;
I don't think that's an objective.&nbsp;&nbsp;

00:15:16.480 --> 00:15:20.560
I'm just talking about informal reasoning,&nbsp;
the same kind of reasoning we use every day to&nbsp;&nbsp;

00:15:20.560 --> 00:15:27.520
decide what we're going to do. We do not take out&nbsp;
category theory and say, you know, we, we actually&nbsp;&nbsp;

00:15:27.520 --> 00:15:33.840
can reason without it. Thank goodness.&nbsp;
So what about, what about the other side?

00:15:33.840 --> 00:15:37.520
Right? There's two things you do with the future&nbsp;
of your software. One is you add new capabilities.&nbsp;&nbsp;

00:15:37.520 --> 00:15:43.360
The other thing is you fix the ones you didn't&nbsp;
get, you know, so, you know, done so well. And&nbsp;&nbsp;

00:15:43.360 --> 00:15:50.320
I like to ask this question. What's true of&nbsp;
every bug found in the field? Got written.&nbsp;&nbsp;

00:15:50.320 --> 00:15:53.840
It got written. Yes. What's a&nbsp;
more interesting fact about it.

00:15:55.520 --> 00:16:05.200
It passed the type checker. What else did it do?&nbsp;
It passed all the tests. Okay. So now what do&nbsp;&nbsp;

00:16:05.200 --> 00:16:14.240
you do? Right. I think we're in this world. I'd&nbsp;
like to call it guard rail programming. Right.&nbsp;&nbsp;

00:16:15.360 --> 00:16:18.800
It's really, really sad. We're like,&nbsp;
I can make change cause I have tests.&nbsp;&nbsp;

00:16:19.520 --> 00:16:23.440
Right? Who does that? Who drives their&nbsp;
car around banging against the door?

00:16:25.200 --> 00:16:30.240
I'm glad I've got these guard rails because&nbsp;
I'd never make it to to the show on time.&nbsp;&nbsp;

00:16:32.080 --> 00:16:38.560
Right. And, and do the guard rails&nbsp;
help you get to where you want to go?&nbsp;&nbsp;

00:16:39.200 --> 00:16:42.240
Like the guard rails, like guide you places. No,&nbsp;&nbsp;

00:16:42.240 --> 00:16:46.080
those guard rails everywhere. They don't, they&nbsp;
don't point your car in any particular direction.

00:16:48.160 --> 00:16:52.160
So again, we're going to need to be able to&nbsp;
think about our program. It's going to be&nbsp;&nbsp;

00:16:52.160 --> 00:16:56.560
critical. All of our guard rails will fall. We'll&nbsp;
have failed us. We're going to have this problem.&nbsp;&nbsp;

00:16:56.560 --> 00:17:02.000
We're going to need to be able to reason about our&nbsp;
program say, well, you know what? I, because maybe&nbsp;&nbsp;

00:17:02.000 --> 00:17:08.800
if it's not too complex, I'll be able to say,&nbsp;
I know through ordinary logic it couldn't be in&nbsp;&nbsp;

00:17:08.800 --> 00:17:12.880
this part of the program. It must be in that part.&nbsp;
And let me go look there first, things like that.

00:17:14.800 --> 00:17:19.360
Now, of course, everybody's going to start&nbsp;
moaning, but I have all this speed. I'm agile&nbsp;&nbsp;

00:17:19.360 --> 00:17:25.440
and fast. You know, this easy stuff is making&nbsp;
my life good cause I have a lot of speed.&nbsp;&nbsp;

00:17:27.360 --> 00:17:36.160
So what kind of runner can run as fast as they&nbsp;
possibly can from the very start of a race, right?

00:17:36.160 --> 00:17:39.520
Only somebody who runs really short races. Okay.&nbsp;&nbsp;

00:17:42.560 --> 00:17:49.200
But of course we are programmers and we're smarter&nbsp;
than runners apparently because we know how to fix&nbsp;&nbsp;

00:17:49.200 --> 00:17:54.720
that problem. Right. We just fire the starting&nbsp;
pistol, every a hundred and call it a new sprint.

00:18:03.360 --> 00:18:10.800
I don't know why they haven't figured that out,&nbsp;
but right. It's my contention based on experience&nbsp;&nbsp;

00:18:11.680 --> 00:18:17.040
that if you ignore complexity, you will slow down.&nbsp;
You will invariably slow down over the long haul.&nbsp;&nbsp;

00:18:18.560 --> 00:18:22.240
Of course, if you are doing something that's&nbsp;
really short term, you don't need any of this.&nbsp;&nbsp;

00:18:22.240 --> 00:18:28.080
You could write it, you know, with ones and&nbsp;
zero's and this is my really scientific graph.

00:18:28.080 --> 00:18:33.520
You notice how none of the axes are, there's no&nbsp;
numbers on it. Cause I just, I completely made&nbsp;&nbsp;

00:18:33.520 --> 00:18:41.840
it up. It's a, it's an experiential graph.&nbsp;
And what it shows is if you focus on ease&nbsp;&nbsp;

00:18:42.640 --> 00:18:48.720
and ignore simplicity. So I'm not saying you&nbsp;
can't try to do both. But if you focus on ease&nbsp;&nbsp;

00:18:48.720 --> 00:18:52.480
you will be able to go as fast as possible from&nbsp;
the beginning of the race, but no matter what&nbsp;&nbsp;

00:18:52.480 --> 00:18:58.240
technology you use or sprints or firing pistols or&nbsp;
whatever the complexity will eventually kill you.

00:18:58.240 --> 00:19:01.680
It will kill you in a way that will&nbsp;
make every sprint accomplish less.&nbsp;&nbsp;

00:19:01.680 --> 00:19:04.800
Most sprints be about completely&nbsp;
redoing things you've already done.&nbsp;&nbsp;

00:19:05.680 --> 00:19:10.960
And the net effect is you're not moving forward&nbsp;
in any significant way. Now, if you start by&nbsp;&nbsp;

00:19:10.960 --> 00:19:15.440
focusing on simplicity, why can't you go as&nbsp;
fast as possible, right at the beginning?

00:19:15.440 --> 00:19:20.960
Okay. Right. Cause some, some tools that are&nbsp;
simple are actually as easy to use as some tools&nbsp;&nbsp;

00:19:20.960 --> 00:19:27.840
that are not, why can't you go as fast, then&nbsp;
you have to think you have to actually apply&nbsp;&nbsp;

00:19:27.840 --> 00:19:32.800
some simplicity, work to the problem before you&nbsp;
start. And that's going to be maybe this ramp up.&nbsp;&nbsp;

00:19:35.920 --> 00:19:40.400
So one of the problems I think we have is&nbsp;
this conundrum that some things that are easy&nbsp;&nbsp;

00:19:40.960 --> 00:19:43.120
actually are, are complex.

00:19:43.120 --> 00:19:50.480
So let's look. There are a bunch of constructs&nbsp;
that have complex artifacts that are very&nbsp;&nbsp;

00:19:50.480 --> 00:19:54.720
succinctly described, right? Some of the things&nbsp;
that are really dangerous to use are like so&nbsp;&nbsp;

00:19:54.720 --> 00:19:59.920
simple to describe they're incredibly familiar,&nbsp;
right? If you're coming from object orientation,&nbsp;&nbsp;

00:19:59.920 --> 00:20:04.800
you're familiar with a lot of complex&nbsp;
things they're very much available, right.

00:20:06.320 --> 00:20:09.200
And they're easy to use. In fact, by all measures,&nbsp;&nbsp;

00:20:09.200 --> 00:20:12.800
conventional measures, you would&nbsp;
look at them and say, this is easy.&nbsp;&nbsp;

00:20:14.160 --> 00:20:18.880
Right. But we don't care about that. Right.&nbsp;
Again, the user's not looking at our software&nbsp;&nbsp;

00:20:18.880 --> 00:20:23.040
and they don't actually care very much about&nbsp;
how good a time we had when we were writing it.

00:20:24.080 --> 00:20:29.600
Right. What they care about is what the&nbsp;
program does and the, and if it works well,&nbsp;&nbsp;

00:20:29.600 --> 00:20:34.720
it will, it will be related to whether&nbsp;
or not the output of those constructs&nbsp;&nbsp;

00:20:34.720 --> 00:20:37.280
were simple. In other words, what,&nbsp;
what complexity do they yield?&nbsp;&nbsp;

00:20:38.240 --> 00:20:43.920
When there is complexity there? We're&nbsp;
going to call that incidental complaint.

00:20:43.920 --> 00:20:48.080
Right. It wasn't part of what the user asked us&nbsp;
to do. We chose the tool, it had some inherent&nbsp;&nbsp;

00:20:48.080 --> 00:20:52.880
complexity in it. It's incidental to the&nbsp;
problem. I didn't put the definition in here.&nbsp;&nbsp;

00:20:53.600 --> 00:21:02.080
But incidental is Latin for "your fault".

00:21:02.080 --> 00:21:05.120
and it is, I think you really&nbsp;
have to ask yourself, you know,&nbsp;&nbsp;

00:21:05.120 --> 00:21:09.040
are you programming with a loom?&nbsp;
You know, you're having a great&nbsp;&nbsp;

00:21:09.040 --> 00:21:12.320
time. You're throwing that shuttle back and&nbsp;
forth and what's coming out the other side&nbsp;&nbsp;

00:21:12.320 --> 00:21:20.240
is this knotted, you know, mess. I mean, it may&nbsp;
look pretty, but you have this problem, right?

00:21:20.240 --> 00:21:29.840
Where's the problem. The problem is the knitted&nbsp;
castle, right? Do you want a knitted castle?&nbsp;&nbsp;

00:21:31.840 --> 00:21:35.200
What benefits do we do we get from&nbsp;
simplicity? We get ease of understanding,&nbsp;&nbsp;

00:21:35.200 --> 00:21:43.120
right? That's sort of definitional. I contend we&nbsp;
get ease of change and easier debugging. Other&nbsp;&nbsp;

00:21:43.120 --> 00:21:48.240
benefits that come out of it that are sort of on&nbsp;
the secondary level are increased flexibility.

00:21:48.240 --> 00:21:51.520
And when we talk more about modularity and&nbsp;
breaking things apart, we'll see where they,&nbsp;&nbsp;

00:21:51.520 --> 00:21:54.640
where that falls like the ability to&nbsp;&nbsp;

00:21:57.200 --> 00:22:03.280
change policies or move things around. Right. As&nbsp;
we make things simpler, we get more independence&nbsp;&nbsp;

00:22:03.280 --> 00:22:09.520
of decisions because they're not interleaved. So&nbsp;
I can make a location decision that's orthogonal&nbsp;&nbsp;

00:22:09.520 --> 00:22:15.920
from a like a performance decision. And I really&nbsp;
do want to make, you know, ask the question&nbsp;&nbsp;

00:22:16.800 --> 00:22:23.040
agilist or whatever it is is having a test&nbsp;
suite and refactoring tools going to make&nbsp;&nbsp;

00:22:24.080 --> 00:22:32.640
changing the knitted castle faster than changing&nbsp;
the Lego castle. No way, completely unrelated.&nbsp;&nbsp;

00:22:34.560 --> 00:22:37.280
Okay. So how do we make things easy?

00:22:37.280 --> 00:22:42.640
Presumably, you know, the objective here is&nbsp;
not to just bemoan the software crisis. Right?

00:22:42.640 --> 00:22:44.640
So what can we do to make things&nbsp;
easier? So we'll look at those&nbsp;&nbsp;

00:22:44.640 --> 00:22:48.000
parts, those aspects of being easy.&nbsp;
Again, there's a location aspect,&nbsp;&nbsp;

00:22:48.800 --> 00:22:52.800
making something at hand, putting it in&nbsp;
our tool kit. That's relatively simple.

00:22:53.360 --> 00:22:57.200
Right? We just install it. Right. Maybe&nbsp;
it's a little bit harder because we have&nbsp;&nbsp;

00:22:57.200 --> 00:23:03.280
to get somebody to say, it's okay to use it. Then&nbsp;
there's the aspect of how do I make it familiar?&nbsp;&nbsp;

00:23:03.280 --> 00:23:06.880
Right. I may not have ever seen this&nbsp;
before. That's a learning exercise.&nbsp;&nbsp;

00:23:06.880 --> 00:23:10.960
I've got to, you'll get a book, go take a&nbsp;
tutorial, have somebody to explain it to me.

00:23:10.960 --> 00:23:16.960
Maybe try it out. Both these things are we're&nbsp;
driving, we're driving. We install, we learn&nbsp;&nbsp;

00:23:16.960 --> 00:23:23.040
where it's totally in our hands. Then we have&nbsp;
this other part though. Right. Which is the mental&nbsp;&nbsp;

00:23:23.040 --> 00:23:28.640
capability part. And does the part, that's always&nbsp;
hard to talk about the mental capability part.&nbsp;&nbsp;

00:23:28.640 --> 00:23:33.760
Maybe because the fact is&nbsp;
we can learn more things.

00:23:33.760 --> 00:23:38.800
We actually can't get much smarter. We're&nbsp;
not going to move. We're not going to move&nbsp;&nbsp;

00:23:38.800 --> 00:23:45.040
our brain closer to the complexity. We have&nbsp;
to make things near by simplifying them.&nbsp;&nbsp;

00:23:45.040 --> 00:23:47.840
The, but the truth here is not that&nbsp;
that's like there are these super,&nbsp;&nbsp;

00:23:47.840 --> 00:23:53.120
super you know, bright people who can do these&nbsp;
amazing things and, and everybody else is stuck.

00:23:54.080 --> 00:23:59.280
Because the juggling analogy is pretty&nbsp;
close, right? The average juggler can do&nbsp;&nbsp;

00:23:59.280 --> 00:24:05.520
three balls. The most amazing juggler in&nbsp;
the world can do like nine balls or 12 or&nbsp;&nbsp;

00:24:05.520 --> 00:24:11.920
something like that. They can't do 20 or a&nbsp;
hundred. Right? All, we're all very limited,&nbsp;&nbsp;

00:24:12.960 --> 00:24:16.640
you know, compared to the complexity&nbsp;
we can create, we're all, you know,&nbsp;&nbsp;

00:24:16.640 --> 00:24:20.960
statistically at the same point in our ability&nbsp;
to understand it, which is not very good.

00:24:21.600 --> 00:24:26.640
So we're going to have to bring things towards&nbsp;
us and because we can only juggle so many balls,&nbsp;&nbsp;

00:24:26.640 --> 00:24:29.440
you have to make a decision.&nbsp;
How many of those balls&nbsp;&nbsp;

00:24:30.400 --> 00:24:35.760
do you want to be incidental complexity and&nbsp;
how many do you want to be? Right. How many&nbsp;&nbsp;

00:24:35.760 --> 00:24:39.440
extra balls you won't have somebody throwing your&nbsp;
balls that you have to try to incorporate in here?

00:24:39.440 --> 00:24:45.840
Oh, use this tool. And you're like, whoa. You&nbsp;
know, more, more stuff who wants to do that?&nbsp;&nbsp;

00:24:46.960 --> 00:24:49.760
All right. So let's look&nbsp;
at a, let's look at a fact.

00:24:54.240 --> 00:24:59.680
So I've been on the other side of this&nbsp;
complaint and I, I like it. We can look&nbsp;&nbsp;

00:24:59.680 --> 00:25:05.920
at it really quickly. Only because it, it's&nbsp;
not, this analysis has nothing to do with the&nbsp;&nbsp;

00:25:05.920 --> 00:25:11.760
usage. This complexity analysis is just about the&nbsp;
programmer experience, right. So parens are hard,&nbsp;&nbsp;

00:25:12.400 --> 00:25:16.000
right? They're not at hand for most&nbsp;
people who haven't otherwise used it.

00:25:16.000 --> 00:25:22.000
And what does that mean? It means that like,&nbsp;
they don't have an editor that knows how to do,&nbsp;&nbsp;

00:25:22.000 --> 00:25:26.000
you know, paren matching or move stuff around&nbsp;
structurally, or they have one and they've never&nbsp;&nbsp;

00:25:26.000 --> 00:25:32.640
loaded the mode that makes that happen. Totally&nbsp;
given. Right. It's. Nor is it familiar? I mean,&nbsp;&nbsp;

00:25:32.640 --> 00:25:36.800
everybody's seen parentheses, but they&nbsp;
haven't seen them on that side of the method!

00:25:38.720 --> 00:25:44.320
I mean, it's just crazy,&nbsp;&nbsp;

00:25:50.400 --> 00:25:54.000
but you know, I think this it's,&nbsp;
this is your responsibility,&nbsp;&nbsp;

00:25:54.000 --> 00:25:57.520
right? To fix these two things&nbsp;
as a user, as a potential user,&nbsp;&nbsp;

00:25:57.520 --> 00:26:02.160
you got to do this. But we could dig deeper. Let's&nbsp;
look at the third thing. Did you actually give me&nbsp;&nbsp;

00:26:02.160 --> 00:26:08.800
something that was simple. Is a language built&nbsp;
all out of parens simple in the case I'm saying?

00:26:09.600 --> 00:26:16.640
Is it free of interleaving and braiding? And&nbsp;
the answer is no right. CommonLisp and Scheme&nbsp;&nbsp;

00:26:17.600 --> 00:26:23.600
are not simple in this sense, in their use of&nbsp;
parens because the use of parentheses in those&nbsp;&nbsp;

00:26:23.600 --> 00:26:32.640
languages is overloaded, right? Parens wrap calls,&nbsp;
they wrap grouping, they wrap data structures,&nbsp;&nbsp;

00:26:33.520 --> 00:26:39.120
right? That overloading is a form of complexity&nbsp;
by the definition of, you know, I gave you, right.

00:26:39.920 --> 00:26:43.840
And so if you actually bothered to get&nbsp;
your editor set up and learn that the&nbsp;&nbsp;

00:26:43.840 --> 00:26:50.000
parenthesis goes on the other side of the&nbsp;
verb this was still a valid complaint. Now,&nbsp;&nbsp;

00:26:50.000 --> 00:26:54.240
of course, everybody was saying easy. It's&nbsp;
hard. It's complex in that we're using these&nbsp;&nbsp;

00:26:54.240 --> 00:26:59.280
words really weekly. Right. But it was hard&nbsp;
for a couple of reasons you could solve.

00:26:59.280 --> 00:27:03.120
And it was not simple for a reason that&nbsp;
was the fault of the language designer,&nbsp;&nbsp;

00:27:03.120 --> 00:27:08.560
which was that there was overloading. Right. And&nbsp;
we can fix that. Right. Just add another data&nbsp;&nbsp;

00:27:08.560 --> 00:27:13.360
structure. It doesn't make lists, not lisp to have&nbsp;
more data structures, right. It's still a language&nbsp;&nbsp;

00:27:13.360 --> 00:27:18.960
defined in terms of its own data structures, but&nbsp;
having more data structures in play means that&nbsp;&nbsp;

00:27:18.960 --> 00:27:24.240
we can get rid of this overloading in this&nbsp;
case, which then makes it your fault again.

00:27:25.040 --> 00:27:28.720
Right. Because now this, the&nbsp;
simplicity is back in the construct.&nbsp;&nbsp;

00:27:28.720 --> 00:27:33.840
And it's just a familiarity thing,&nbsp;
which you can solve for yourself.

00:27:35.200 --> 00:27:45.200
Okay. This is an old dig at list programmers.&nbsp;
I'm not totally sure what the what he was talking&nbsp;&nbsp;

00:27:45.200 --> 00:27:49.440
about. I believe it was a performance related&nbsp;
thing that lispers would just, they cons'ed up&nbsp;&nbsp;

00:27:49.440 --> 00:27:54.560
all this memory and they did all this evaluation&nbsp;
and it was, it was a pig. LISP programs at that&nbsp;&nbsp;

00:27:54.560 --> 00:27:58.320
time were, were LISP programs at that time&nbsp;
were complete pigs relative to the hardware.

00:27:59.200 --> 00:28:02.560
So they, you know, they knew the value of&nbsp;
all these constructs, right? This dynamism,&nbsp;&nbsp;

00:28:02.560 --> 00:28:07.360
dynamic nature, these things are all great.&nbsp;
They are valuable. Right. But there was this&nbsp;&nbsp;

00:28:07.360 --> 00:28:13.680
performance cost. I'd like to lift this whole&nbsp;
phrase and apply it to all of us right now.&nbsp;&nbsp;

00:28:13.680 --> 00:28:17.120
Right. As programmers, we are&nbsp;
looking at all kinds of things.

00:28:17.120 --> 00:28:21.040
And I just see it, you know, read hacker news&nbsp;
or whatever. It's like, oh, look, this thing has&nbsp;&nbsp;

00:28:21.040 --> 00:28:25.360
this benefit. Oh, great. I'm going to do that.&nbsp;
Oh, but this has this benefit. Oh, that's cool.&nbsp;&nbsp;

00:28:26.000 --> 00:28:33.120
Oh, that's awesome. You know, that's shorter.&nbsp;
You never see in these discussions, was there a&nbsp;&nbsp;

00:28:33.120 --> 00:28:37.600
trade off? Is there any downside, you know, is&nbsp;
there anything bad that comes along with this?

00:28:37.600 --> 00:28:42.400
Never nothing. It's just like, we look all for&nbsp;
benefits, right? So as programmers now, I think&nbsp;&nbsp;

00:28:42.400 --> 00:28:47.040
we're, we're looking all for benefits and we're&nbsp;
not looking carefully enough at the byproducts.&nbsp;&nbsp;

00:28:49.040 --> 00:28:57.920
So what's in your toolkit. I have&nbsp;
you know, I have these two columns,&nbsp;&nbsp;

00:28:57.920 --> 00:29:04.000
one says complexity, and one says, simplicity,&nbsp;
the simplicity column just being simpler.

00:29:04.880 --> 00:29:07.440
It doesn't mean that the things&nbsp;
over there are purely simple.&nbsp;&nbsp;

00:29:09.040 --> 00:29:15.520
I didn't label these things bad and&nbsp;
good. I'm leaving your minds to do that.

00:29:21.600 --> 00:29:25.280
So what, what things are complex and what are&nbsp;
the simple replacements. I'm going to dig into&nbsp;&nbsp;

00:29:25.280 --> 00:29:27.840
the details on these. So I won't actually&nbsp;
explain why they're complex. We're going&nbsp;&nbsp;

00:29:27.840 --> 00:29:34.800
to say state and objects are complex and values&nbsp;
are simple and can replace them. In many cases,&nbsp;&nbsp;

00:29:35.600 --> 00:29:40.720
I'm going to say methods are complex and&nbsp;
functions are simple and namespaces are simple.

00:29:40.720 --> 00:29:47.840
And the reason why methods are there because often&nbsp;
the, the space of methods the class or whatever&nbsp;&nbsp;

00:29:47.840 --> 00:29:56.640
is also a mini very poor namespace. vars&nbsp;
are complex, and variables are complex.&nbsp;&nbsp;

00:29:57.280 --> 00:30:00.640
Managed references are also&nbsp;
complex, but they're still simpler.&nbsp;&nbsp;

00:30:02.720 --> 00:30:10.240
Inheritance, switch statements, pattern matching&nbsp;
are all complex and polymorphism ala carte is&nbsp;&nbsp;

00:30:10.240 --> 00:30:19.040
simple. Okay. Now remember the meaning of simple,&nbsp;
meaning of simple means unentangled. Right.&nbsp;&nbsp;

00:30:19.040 --> 00:30:23.600
Not twisted together with something else. It&nbsp;
doesn't mean I already know what it means. Right?&nbsp;&nbsp;

00:30:23.600 --> 00:30:30.480
Simple. Does not mean "I already know what it&nbsp;
means." Okay. Syntax is complex. Data is simple.&nbsp;&nbsp;

00:30:33.360 --> 00:30:37.360
Imperative loops, fold, even&nbsp;
which seems kind of higher level&nbsp;&nbsp;

00:30:37.360 --> 00:30:40.000
still has some implications&nbsp;
that tie two things together.

00:30:40.000 --> 00:30:45.920
Whereas set functions are simpler.&nbsp;
Actors are complex and cues are simpler.&nbsp;&nbsp;

00:30:47.120 --> 00:30:52.720
ORM is complex and declarative&nbsp;
data manipulation is simpler.&nbsp;&nbsp;

00:30:52.720 --> 00:30:57.360
Okay. Even Eric said that in his talk,&nbsp;
he said it really fast near the end.

00:31:00.400 --> 00:31:03.840
"Oh yeah. And eventual consistency&nbsp;
is really hard for programs."

00:31:07.840 --> 00:31:16.080
Conditionals are complex in interesting ways and&nbsp;
rules can be, can be simpler. And inconsistency&nbsp;&nbsp;

00:31:16.080 --> 00:31:20.480
is very complex. It's almost definitionally&nbsp;
complex, right? Because consistent means&nbsp;&nbsp;

00:31:20.480 --> 00:31:25.120
to stand together. So inconsistent means to&nbsp;
stand apart. And that means taking a set of&nbsp;&nbsp;

00:31:25.120 --> 00:31:27.920
things that are standing apart and trying&nbsp;
to think about them all at the same time.

00:31:28.560 --> 00:31:32.880
It's inherently complex to do that. And anybody&nbsp;
who's tried to use a system that's eventually&nbsp;&nbsp;

00:31:32.880 --> 00:31:41.440
consistent knows that. Okay. So there's this&nbsp;
really cool word called complect. I found it.&nbsp;&nbsp;

00:31:43.280 --> 00:31:46.720
I love it. It means to&nbsp;
interleave or entwine or braid.&nbsp;&nbsp;

00:31:47.440 --> 00:31:51.440
Okay. I want to start talking about what&nbsp;
we do to our software that makes it bad.

00:31:52.000 --> 00:31:56.080
I don't want to say braid or entwine&nbsp;
because it doesn't really have the good,&nbsp;&nbsp;

00:31:56.080 --> 00:32:01.040
bad connotation that complect has.&nbsp;
Complect is obviously bad. Right?&nbsp;&nbsp;

00:32:02.320 --> 00:32:05.520
It happens to be an archaic word, but you&nbsp;
know, there's no rules that say you can't&nbsp;&nbsp;

00:32:05.520 --> 00:32:08.320
start using them again. So I'm going&nbsp;
to use them for the rest of the talk.

00:32:09.520 --> 00:32:14.160
So what do you know about&nbsp;
"complect"? It's bad. Don't do it.&nbsp;&nbsp;

00:32:14.160 --> 00:32:21.440
Right. This is where complexity comes from.&nbsp;
Right? Complecting. That's very simple.

00:32:24.720 --> 00:32:28.560
Right? And in particular, it's something&nbsp;
that you want to avoid in the first place.&nbsp;&nbsp;

00:32:28.560 --> 00:32:32.960
Right? Look at this diagram. Look at&nbsp;
the first one. Look at the last one,&nbsp;&nbsp;

00:32:33.520 --> 00:32:39.760
right? It's the same stuff in both those diagrams,&nbsp;
the exact it's the same strips. What happened?&nbsp;&nbsp;

00:32:40.880 --> 00:32:47.760
They got complected. And now it's hard to&nbsp;
understand the bottom diagram from the top&nbsp;&nbsp;

00:32:47.760 --> 00:32:51.680
one, but it's the same stuff.&nbsp;
You're doing this all the time.

00:32:51.680 --> 00:32:53.920
You can make a program, a hundred different ways.&nbsp;&nbsp;

00:32:53.920 --> 00:32:57.440
Some of them it's just hanging there. It's&nbsp;
all straight. You look at it. You say, oh,&nbsp;&nbsp;

00:32:57.440 --> 00:33:01.840
I see it's four lines this program, right. Then&nbsp;
you could type in four lines in another language&nbsp;&nbsp;

00:33:01.840 --> 00:33:07.440
or with a different construct. And you end up with&nbsp;
this knot. So you've got to take care of that.

00:33:08.400 --> 00:33:14.800
So "complect" actually means to braid together.&nbsp;
And "compose" means to place together.&nbsp;&nbsp;

00:33:16.000 --> 00:33:19.840
And we know that right. Everybody keeps telling&nbsp;
us what we want to do is make composable systems.&nbsp;&nbsp;

00:33:19.840 --> 00:33:25.520
We just want to place things together, which&nbsp;
is great. And I think there's no disagreement,&nbsp;&nbsp;

00:33:25.520 --> 00:33:33.200
right? Composing simple components. Simple in that&nbsp;
same respect is the way we write robust software.

00:33:34.720 --> 00:33:41.440
So it's simple. Right? All we need to&nbsp;
do is (everybody knows this I'm up here&nbsp;&nbsp;

00:33:41.440 --> 00:33:45.280
just telling you stuff you know), we can make&nbsp;
simple systems by making them modular. Right.&nbsp;&nbsp;

00:33:47.120 --> 00:33:50.320
We're done. I'm like halfway through my talk.&nbsp;
I don't even know if I'm going to finish.&nbsp;&nbsp;

00:33:50.320 --> 00:33:57.440
It's so simple, right? This is it. This is&nbsp;
the key. No, it's obviously not the key.

00:33:58.240 --> 00:34:01.520
Right? Who has seen components that&nbsp;
have this kind of characteristic?&nbsp;&nbsp;

00:34:04.000 --> 00:34:07.840
I'll raise my hand twice because not enough people&nbsp;
are raising their hands. It's ridiculous. Right?&nbsp;&nbsp;

00:34:07.840 --> 00:34:12.720
What happens? You can write modular software&nbsp;
with all kinds of interconnections between them,&nbsp;&nbsp;

00:34:12.720 --> 00:34:16.960
right? They may not call each other,&nbsp;
but they're completely complected.

00:34:18.720 --> 00:34:24.080
Right. And we know how to solve this. It has&nbsp;
nothing to do with the fact that there are&nbsp;&nbsp;

00:34:24.080 --> 00:34:27.840
two things it has to do with what those&nbsp;
two things are allowed to think about.&nbsp;&nbsp;

00:34:27.840 --> 00:34:32.240
If you want to really anthropomorphize and what&nbsp;
do we want to make things allowed to think about?&nbsp;&nbsp;

00:34:33.280 --> 00:34:38.560
And only these things, some abstractions, I&nbsp;
don't know if that's coming out that well,&nbsp;&nbsp;

00:34:39.200 --> 00:34:43.680
that's a dashed white version&nbsp;
of the top of the LEGO, right?

00:34:43.680 --> 00:34:47.600
That's all we want to limit things to. Cause now&nbsp;
the blue guy doesn't really know anything about&nbsp;&nbsp;

00:34:47.600 --> 00:34:50.400
the yellow guy and the yellow guy doesn't&nbsp;
really know anything about the blue guy&nbsp;&nbsp;

00:34:50.400 --> 00:34:55.440
and they both become simple. So&nbsp;
it's very, it's very important&nbsp;&nbsp;

00:34:55.440 --> 00:34:58.960
that you don't associate simplicity with&nbsp;
partitioning and stratification, right?

00:34:58.960 --> 00:35:03.760
They don't. Right. They are enabled&nbsp;
by it. If you make simple components,&nbsp;&nbsp;

00:35:03.760 --> 00:35:08.960
you can horizontally separate them&nbsp;
and you can vertically stratify them.&nbsp;&nbsp;

00:35:08.960 --> 00:35:14.240
Right. But you can also do that with complex&nbsp;
things and you're going to get no benefits.&nbsp;&nbsp;

00:35:14.240 --> 00:35:20.400
And so I would encourage you to be particularly&nbsp;
careful not to be fooled by code organization.

00:35:20.960 --> 00:35:25.600
Right. There's tons of libraries that look,&nbsp;
oh, look, there's different classes. They're&nbsp;&nbsp;

00:35:25.600 --> 00:35:29.040
separate classes. They, you know, they call&nbsp;
each other and sort of these nice ways,&nbsp;&nbsp;

00:35:29.040 --> 00:35:30.720
right. Then you get out in&nbsp;
the field and you're like,&nbsp;&nbsp;

00:35:30.720 --> 00:35:37.040
oh my God, this thing presumes, that, that&nbsp;
thing never returns to number 17. What is that?

00:35:39.600 --> 00:35:45.120
Okay. I'm not going to get up here and tell&nbsp;
you, state is awesome. I like state. I'm not&nbsp;&nbsp;

00:35:45.120 --> 00:35:52.720
a functional whatever guy, whenever I'm going&nbsp;
to say instead I did this and it sucks. Right.&nbsp;&nbsp;

00:35:52.720 --> 00:36:00.720
I did years and years, C++ you know, He-Man&nbsp;
stateful programming. It's, it's really not fun.&nbsp;&nbsp;

00:36:01.360 --> 00:36:08.000
It's not good. It's, it's never simple. Having&nbsp;
state in your program is never simple, right?

00:36:08.000 --> 00:36:13.920
Because it has a fundamental complecting that&nbsp;
goes on in its artifacts, right? It complects&nbsp;&nbsp;

00:36:13.920 --> 00:36:18.480
value in time. You don't have the&nbsp;
ability to get a value independent of,&nbsp;&nbsp;

00:36:18.480 --> 00:36:25.600
of time, and sometimes not an ability to get&nbsp;
a value in any proper sense at all. But again,&nbsp;&nbsp;

00:36:25.600 --> 00:36:28.880
it's a great example. This is&nbsp;
easy. It's totally familiar.

00:36:28.880 --> 00:36:34.000
It's at hand, it's an, all the programming&nbsp;
languages. This is so easy. This complexity&nbsp;&nbsp;

00:36:34.000 --> 00:36:40.080
is so easy. Okay. And you can't get&nbsp;
rid of it, everything. So I'll have I&nbsp;&nbsp;

00:36:40.080 --> 00:36:44.640
have modularity. And that, that assignment&nbsp;
statement is inside a method, right? Well,&nbsp;&nbsp;

00:36:44.640 --> 00:36:48.320
if every time you call that method with the&nbsp;
same arguments, you can get a different result.

00:36:48.320 --> 00:36:52.240
Guess what happened? That complexity. It&nbsp;
just leaked right out of there. It doesn't&nbsp;&nbsp;

00:36:52.240 --> 00:36:56.400
matter that you can't see the variable,&nbsp;
right? If the thing that's wrapping it is&nbsp;&nbsp;

00:36:56.400 --> 00:36:58.800
stateful. And the thing that's wrapping&nbsp;
that is still stateful. In other words,&nbsp;&nbsp;

00:36:58.800 --> 00:37:02.000
by stateful, I mean, every time we ask it the&nbsp;
same question, you get a different answer.

00:37:02.960 --> 00:37:07.360
You have this complexity and it's like&nbsp;
poison and it's like dropping, you know,&nbsp;&nbsp;

00:37:07.360 --> 00:37:13.040
some, some dark liquid into this, to a vase. It's&nbsp;
just going to end up all over the place. The only&nbsp;&nbsp;

00:37:13.040 --> 00:37:17.600
time you can really get rid of it is when you&nbsp;
put it inside something that's able to present&nbsp;&nbsp;

00:37:17.600 --> 00:37:21.840
a functional interface on the outside, a true&nbsp;
functional interface, same input, same output.

00:37:23.920 --> 00:37:28.000
You can't mitigate it through the&nbsp;
ordinary code organization things.&nbsp;&nbsp;

00:37:28.800 --> 00:37:31.920
And note in particular, I didn't&nbsp;
talk about concurrency here.&nbsp;&nbsp;

00:37:31.920 --> 00:37:37.120
This is not about concurrency. This has nothing&nbsp;
to do with concurrency. It's about your ability&nbsp;&nbsp;

00:37:37.120 --> 00:37:41.440
to understand your program. Your program was&nbsp;
out there, it's single-threaded it didn't work.

00:37:41.440 --> 00:37:46.000
All the tests passed. It, made it through&nbsp;
the type checker, figure out what happened,&nbsp;&nbsp;

00:37:46.000 --> 00:37:52.240
right? If it's full of variables, where are&nbsp;
you going to need to try that? Recreate the&nbsp;&nbsp;

00:37:52.240 --> 00:37:59.040
state that was happening at the client when&nbsp;
it went bad. Is that going to be easy? No.&nbsp;&nbsp;

00:38:02.080 --> 00:38:06.640
But we fixed this, right? Your language, your&nbsp;
new shiny language has something called var&nbsp;&nbsp;

00:38:07.280 --> 00:38:10.080
or maybe it has refs or references.

00:38:11.360 --> 00:38:16.000
None of these constructs make state simple.&nbsp;
That's the first primary thing. I don't want&nbsp;&nbsp;

00:38:16.000 --> 00:38:19.120
to say that even of Clojure's constructs,&nbsp;
they do not make state simple in the case&nbsp;&nbsp;

00:38:19.120 --> 00:38:21.920
I'm talking about in the, in the&nbsp;
nature of simple I'm talking about&nbsp;&nbsp;

00:38:22.480 --> 00:38:25.920
but they're not the same, right? They&nbsp;
all do warn you when you have state.

00:38:25.920 --> 00:38:30.320
And that's great. Most people who are&nbsp;
using a language where immutability is&nbsp;&nbsp;

00:38:30.320 --> 00:38:34.080
not the default, and you have to go out of&nbsp;
your way to get it, finds that the programs&nbsp;&nbsp;

00:38:34.080 --> 00:38:38.960
they end up writing have dramatically like&nbsp;
orders of magnitude, less state than they&nbsp;&nbsp;

00:38:38.960 --> 00:38:42.080
would otherwise. Cause they never needed&nbsp;
all the other state in the first place.

00:38:42.960 --> 00:38:48.480
So that's really great. But I will call&nbsp;
out Clojure and Haskell's references as&nbsp;&nbsp;

00:38:48.480 --> 00:38:52.880
being particularly superior in&nbsp;
dealing with this because they&nbsp;&nbsp;

00:38:52.880 --> 00:38:56.240
compose values and time. They're&nbsp;
actually little constructs that do&nbsp;&nbsp;

00:38:56.240 --> 00:39:01.200
two things. They have some abstraction over&nbsp;
time and the ability to extract the value.

00:39:03.360 --> 00:39:09.360
That's really important. Because that's, that's&nbsp;
your path back to simplicity. I mean, if I have&nbsp;&nbsp;

00:39:09.360 --> 00:39:12.960
a way to get out of this thing and get a value&nbsp;
out, I can continue with my program after I've&nbsp;&nbsp;

00:39:12.960 --> 00:39:16.080
passed that variable to somebody else or&nbsp;
a reference to something that's going to&nbsp;&nbsp;

00:39:16.080 --> 00:39:20.720
find the variable every time through the varying&nbsp;
thing, I'm poisoning the rest of my system.

00:39:21.520 --> 00:39:25.600
So you know, look at the var in your&nbsp;
language and ask if it does the same,&nbsp;&nbsp;

00:39:25.600 --> 00:39:31.120
the same thing. All right, let's see why&nbsp;
things are complex. State. We already&nbsp;&nbsp;

00:39:31.120 --> 00:39:37.600
talked about it complects everything&nbsp;
it touches. objects, complect state,&nbsp;&nbsp;

00:39:37.600 --> 00:39:42.720
identity and value. They mix these three things&nbsp;
up in a way that you cannot extricate the parts.

00:39:43.760 --> 00:39:50.640
Methods complect function and state ordinarily,&nbsp;
right? In addition, in some languages they&nbsp;&nbsp;

00:39:50.640 --> 00:39:55.840
complect namespaces right. Derive from two&nbsp;
things in Java, they have the same name, method.&nbsp;&nbsp;

00:39:57.120 --> 00:40:00.720
It doesn't work. syntax, interestingly&nbsp;&nbsp;

00:40:01.760 --> 00:40:05.440
complects meaning and order often&nbsp;
in a very unidirectional way.&nbsp;&nbsp;

00:40:06.960 --> 00:40:14.240
Professor Sussman made the great point about data&nbsp;
versus syntax and it, you know, it's super true.

00:40:14.240 --> 00:40:19.520
I don't care how much you really love the syntax&nbsp;
of your favorite language. It's inferior to data&nbsp;&nbsp;

00:40:19.520 --> 00:40:26.160
in every way. Inheritance complects types,&nbsp;
right? So it says these two types are complected,&nbsp;&nbsp;

00:40:26.160 --> 00:40:30.080
that's what it means. Inheritance.&nbsp;
Complecting. It's like it's,&nbsp;&nbsp;

00:40:30.080 --> 00:40:34.000
it's definitional, right? Switching and matching.

00:40:34.560 --> 00:40:40.320
They complect multiple pairs of&nbsp;
who's going to do something and&nbsp;&nbsp;

00:40:40.320 --> 00:40:46.720
what happens. Right. And they do it all in&nbsp;
one place in a closed way. That's very bad.&nbsp;&nbsp;

00:40:48.320 --> 00:40:53.680
Vars and variables, again, complect value&nbsp;
in time, often in an inextricable way, you&nbsp;&nbsp;

00:40:53.680 --> 00:41:01.040
can't obtain a value. We saw a picture during a&nbsp;
keynote yesterday this amazing memory, right where&nbsp;&nbsp;

00:41:01.040 --> 00:41:07.760
you could dereference uh, an address and get an&nbsp;
object out. I want to get one of those computers.

00:41:08.400 --> 00:41:12.080
Right. Have you ever used one of those&nbsp;
computers? I can't get one. I called Apple&nbsp;&nbsp;

00:41:12.080 --> 00:41:16.880
and they were like, no. The only thing you can&nbsp;
never get out of a memory address is a word,&nbsp;&nbsp;

00:41:16.880 --> 00:41:21.840
a scalar, right? The thing that was all&nbsp;
derided, right? Recovering a composite&nbsp;&nbsp;

00:41:21.840 --> 00:41:26.160
object from an address. It's not something&nbsp;
computers do. None of the ones that we have.

00:41:27.280 --> 00:41:32.000
So variables have the same problem. You&nbsp;
can not recover a composite mutable thing&nbsp;&nbsp;

00:41:32.000 --> 00:41:40.320
with, with one dereference. Loops and fold&nbsp;
loops are pretty obviously. Complecting what&nbsp;&nbsp;

00:41:40.320 --> 00:41:45.200
you're doing and how to do it. Fold is a little&nbsp;
bit more subtle, right? Cause it seems like this&nbsp;&nbsp;

00:41:45.200 --> 00:41:49.120
nice. Somebody else has taken care of it, but&nbsp;
it does have this implication about the order&nbsp;&nbsp;

00:41:49.120 --> 00:41:55.120
of things this left to right bit. Actors complect&nbsp;
what's going to be done and who's going to do it.

00:42:00.880 --> 00:42:06.800
Now professor Sussman said the, all these&nbsp;
talks have acronyms and I couldn't actually&nbsp;&nbsp;

00:42:06.800 --> 00:42:13.360
modify my slides in time. So object relational&nbsp;
mapping has, oh my God complecting going on.&nbsp;&nbsp;

00:42:14.720 --> 00:42:17.920
You can't even begin to talk&nbsp;
about how, how bad it is.&nbsp;&nbsp;

00:42:17.920 --> 00:42:24.720
Right. And, and, and you know, if&nbsp;
you're going to do like, duals, right?

00:42:25.280 --> 00:42:32.480
What's the dual of value, is it co-alue?&nbsp;
What's a co-value? It's an inconsistent.

00:42:35.680 --> 00:42:38.640
Who wants that. And conditionals, I&nbsp;
think are interesting, right? This is,&nbsp;&nbsp;

00:42:38.640 --> 00:42:42.400
this is sort of more cutting edge area. We&nbsp;
have a bunch of sort of rules about what&nbsp;&nbsp;

00:42:42.400 --> 00:42:44.640
our program's supposed to do. It's&nbsp;
strewn all throughout the program.&nbsp;&nbsp;

00:42:48.560 --> 00:42:51.120
Can we fix that? because that's complected with&nbsp;&nbsp;

00:42:51.120 --> 00:42:53.440
the structure of the program and&nbsp;
the organization of the program.

00:42:54.640 --> 00:43:02.320
All right. So if you take away two things&nbsp;
from this talk one would be the difference&nbsp;&nbsp;

00:43:02.320 --> 00:43:07.600
between the words "simple" and "easy". The&nbsp;
other, I would hope would be the fact that&nbsp;&nbsp;

00:43:07.600 --> 00:43:15.360
we can create precisely the same programs we're&nbsp;
creating right now with these tools of complexity&nbsp;&nbsp;

00:43:15.360 --> 00:43:18.640
with dramatically drastically simpler tools.

00:43:19.280 --> 00:43:26.480
Right. I did C++ for a long time, I did Java. I&nbsp;
did C#. I know how to make big systems in those&nbsp;&nbsp;

00:43:26.480 --> 00:43:33.360
languages. And I completely. You do not need all&nbsp;
that complexity. You can write as sophisticated&nbsp;&nbsp;

00:43:33.360 --> 00:43:38.160
a system with dramatically simpler tools, which&nbsp;
means you're gonna be focusing on the system,&nbsp;&nbsp;

00:43:38.160 --> 00:43:43.440
what is supposed to do instead of all the guck&nbsp;
that falls out of the constructs you're using.

00:43:43.440 --> 00:43:48.960
So I'd love to say the first step in getting a&nbsp;
simpler life is to just choose simpler stuff,&nbsp;&nbsp;

00:43:50.080 --> 00:43:53.920
right? So if you want values, usually you&nbsp;
can get it. Most languages have something&nbsp;&nbsp;

00:43:53.920 --> 00:44:00.880
like values final or, or val you know, lets&nbsp;
you like declare something as being immutable.&nbsp;&nbsp;

00:44:00.880 --> 00:44:02.800
You do want to find some persistent collections.

00:44:02.800 --> 00:44:08.400
Cause the harder thing in a lot of languages&nbsp;
is getting aggregates that are values,&nbsp;&nbsp;

00:44:09.120 --> 00:44:12.480
right? You got to find a good library for that&nbsp;
or use a language where that's the default.&nbsp;&nbsp;

00:44:17.120 --> 00:44:21.280
Functions. Most languages have them. Thank&nbsp;
goodness. If you don't know what they are, they're&nbsp;&nbsp;

00:44:21.280 --> 00:44:27.040
like stateless methods. Namespaces is something&nbsp;
you really need the language to do for you.

00:44:27.040 --> 00:44:32.160
And unfortunately, it's not done very&nbsp;
well in a lot of places. Data. Please,&nbsp;&nbsp;

00:44:33.680 --> 00:44:36.640
programmers. We supposedly&nbsp;
write data processing programs.&nbsp;&nbsp;

00:44:36.640 --> 00:44:39.440
There's all these programs, they don't&nbsp;
have any data in them. They have all these&nbsp;&nbsp;

00:44:40.080 --> 00:44:45.440
constructs. We put around it and globbed on&nbsp;
top of data. Data is actually really simple.

00:44:45.440 --> 00:44:47.280
There's not, there's not a tremendous number of&nbsp;&nbsp;

00:44:47.280 --> 00:44:51.840
variations in the central nature of data,&nbsp;
right? There are maps. There are sets, there are&nbsp;&nbsp;

00:44:51.840 --> 00:44:57.200
linear, sequential things. There's not a&nbsp;
lot of other conceptual categories of data.&nbsp;&nbsp;

00:44:57.200 --> 00:45:01.920
We create hundreds of thousands of variations,&nbsp;
have nothing to do with the essence of the stuff&nbsp;&nbsp;

00:45:01.920 --> 00:45:05.040
and make it hard to write programs that&nbsp;
manipulate the essence of the stuff.

00:45:05.040 --> 00:45:10.720
We should just manipulate the essence of&nbsp;
the stuff it's not hard. It's simpler. Also&nbsp;&nbsp;

00:45:10.720 --> 00:45:17.120
same thing for communications, right? Are we&nbsp;
all not glad we don't use the Unix method of&nbsp;&nbsp;

00:45:17.120 --> 00:45:25.040
communicating on the web? Any arbitrary command&nbsp;
string can be the argument list for your program&nbsp;&nbsp;

00:45:25.040 --> 00:45:29.120
and any arbitrary set of characters can come&nbsp;
out the other end. Let's all write parsers.&nbsp;&nbsp;

00:45:31.360 --> 00:45:35.120
No, I mean, it's, it's a problem.&nbsp;
It's, it's a source of complexity,&nbsp;&nbsp;

00:45:35.120 --> 00:45:38.880
right? So we can get rid of that. Just use&nbsp;
data. The biggest thing, I think the most&nbsp;&nbsp;

00:45:38.880 --> 00:45:43.520
desirable thing, the most esoteric, this&nbsp;
is tough to get, but boy, when you have it,&nbsp;&nbsp;

00:45:43.520 --> 00:45:49.600
your life is completely, totally different&nbsp;
thing is polymorphism ala carte, right?

00:45:49.600 --> 00:45:56.400
Clojure protocols and Haskell type classes. And,&nbsp;
and constructs like that give you the ability&nbsp;&nbsp;

00:45:56.400 --> 00:46:03.200
to independently say I have data structures.&nbsp;
I have definitions of sets of functions and I&nbsp;&nbsp;

00:46:03.200 --> 00:46:07.040
can connect them together. And those&nbsp;
are three independent operations.&nbsp;&nbsp;

00:46:07.920 --> 00:46:13.440
In other words the genericity is not tied to&nbsp;
anything in particular. It's available ala carte.

00:46:14.000 --> 00:46:17.920
I don't know of a lot of library solutions for&nbsp;
languages that don't have it. Already talked about&nbsp;&nbsp;

00:46:17.920 --> 00:46:23.200
managed references and how to get them. Maybe you&nbsp;
can use Clojure's from different Java languages.&nbsp;&nbsp;

00:46:23.920 --> 00:46:26.960
Set functions. You can get from libraries.&nbsp;
Queues, you can get from libraries,&nbsp;&nbsp;

00:46:26.960 --> 00:46:29.760
right? You don't need a&nbsp;
special communication language.

00:46:29.760 --> 00:46:35.200
You can get declarative data manipulation&nbsp;
by using SQL or learning SQL finally,&nbsp;&nbsp;

00:46:37.840 --> 00:46:42.240
or something like LINQ or something like&nbsp;
datalog. I think these last couple of things are&nbsp;&nbsp;

00:46:42.240 --> 00:46:46.320
harder, right? We don't have a lot&nbsp;
of ways to do this. Well-integrated&nbsp;&nbsp;

00:46:46.320 --> 00:46:51.840
with our languages. I think at currently,&nbsp;
LINQ is an effort to do that. Rules, right?

00:46:51.840 --> 00:46:57.760
Declarative rule systems, instead of embedding&nbsp;
a bunch of conditionals in our raw language at&nbsp;&nbsp;

00:46:57.760 --> 00:47:02.480
every point of decision, it's nice to sort of&nbsp;
gather that stuff and put it over someplace&nbsp;&nbsp;

00:47:02.480 --> 00:47:07.840
else. And you can get rules systems in libraries,&nbsp;
or you can use languages like Prolog. If you want&nbsp;&nbsp;

00:47:07.840 --> 00:47:11.520
consistency, you need to use&nbsp;
transactions and you need to use values.

00:47:12.240 --> 00:47:16.400
Okay. There are reasons why you&nbsp;
might have to get off of this list,&nbsp;&nbsp;

00:47:16.400 --> 00:47:23.920
but boy, there's no reason why you shouldn't start&nbsp;
with it. Okay. There's a source of complexity.&nbsp;&nbsp;

00:47:23.920 --> 00:47:30.240
That's really difficult to deal with and not your&nbsp;
fault. Call it environmental complexity, right?&nbsp;&nbsp;

00:47:30.240 --> 00:47:35.520
Our programs end up running on machines next to&nbsp;
other programs next to other parts of themselves.

00:47:35.520 --> 00:47:42.640
And they contend, they contend for stuff,&nbsp;
right? Memory, CPU cycles, and things like that.&nbsp;&nbsp;

00:47:43.360 --> 00:47:49.280
Everybody's contending for it. This is an inherent&nbsp;
complexity. Inherent is Latin for "not your fault"&nbsp;&nbsp;

00:47:51.200 --> 00:47:53.840
in the implementation space. And&nbsp;
those is not part of the problem,&nbsp;&nbsp;

00:47:54.560 --> 00:47:56.160
but it is part of the implementation, right?

00:47:56.160 --> 00:47:57.680
You can't go back to the customer and say,&nbsp;&nbsp;

00:47:57.680 --> 00:48:03.440
the thing you wanted is not good because I&nbsp;
have GC problems. But did you see problems&nbsp;&nbsp;

00:48:03.440 --> 00:48:07.280
and stuff like that? They, they come into&nbsp;
play. There's not a lot of great solutions,&nbsp;&nbsp;

00:48:07.280 --> 00:48:10.080
right? You can do segmentation. You can say,&nbsp;
this is your memory. This is your memory.

00:48:10.080 --> 00:48:14.800
This is your memory. This is your CPU and your&nbsp;
CPU. But there's tremendous waste in that,&nbsp;&nbsp;

00:48:14.800 --> 00:48:19.200
right? Because you pre allocate, you don't use&nbsp;
everything, you don't have sort of dynamic nature.&nbsp;&nbsp;

00:48:19.920 --> 00:48:23.360
But the problem I think we're facing, and&nbsp;
it's not one for which I have a solution&nbsp;&nbsp;

00:48:23.360 --> 00:48:27.280
at the moment, is that the policies&nbsp;
around this stuff don't compose.

00:48:28.080 --> 00:48:30.880
Right. If everybody says I'll just&nbsp;
size my thread pool to be the number of&nbsp;&nbsp;

00:48:31.920 --> 00:48:35.040
cores. Well, how many times&nbsp;
can you do that in one program.&nbsp;&nbsp;

00:48:36.400 --> 00:48:41.840
Not a lot and have it still work out. Yeah.&nbsp;
So unfortunately a lot of things like that&nbsp;&nbsp;

00:48:43.040 --> 00:48:48.880
splitting that stuff up and making an individual&nbsp;
decision is not actually making things simpler.

00:48:48.880 --> 00:48:52.240
It's making things complex because&nbsp;
that's a decision that needs to be made&nbsp;&nbsp;

00:48:52.240 --> 00:48:57.760
by someone who has better information. And I&nbsp;
don't think we have a lot of good sources for,&nbsp;&nbsp;

00:48:59.280 --> 00:49:05.040
organizing those decisions in, in single places,&nbsp;
in our systems. This is a hugely long quote.&nbsp;&nbsp;

00:49:06.880 --> 00:49:18.400
Basically it says programming is not about typing,&nbsp;
it's about thinking. So the next phase here,&nbsp;&nbsp;

00:49:18.400 --> 00:49:23.200
I gotta move a little bit quicker is how do we&nbsp;
design simple things of our own? Right. So the&nbsp;&nbsp;

00:49:23.200 --> 00:49:28.080
first part of making things simple is just to&nbsp;
choose constructs that have simple artifacts,&nbsp;&nbsp;

00:49:28.080 --> 00:49:33.360
but we have to write our own constructs sometimes.&nbsp;
So how do we abstract for simplicity, right.

00:49:33.360 --> 00:49:39.200
And abstract again, here's an actual definition,&nbsp;
not made up one, means to draw something away.&nbsp;&nbsp;

00:49:39.200 --> 00:49:44.720
And in particular it means to draw away from&nbsp;
the physical nature of something. I do want to&nbsp;&nbsp;

00:49:44.720 --> 00:49:49.440
distinguish this from the, sometimes people&nbsp;
use this term really grossly to just mean&nbsp;&nbsp;

00:49:49.440 --> 00:49:54.880
hiding stuff. That is not what abstraction is,&nbsp;
and that's not going to help you in this space.

00:49:55.840 --> 00:50:01.920
There's too you know, I can't totally explain how&nbsp;
this is done. It's really the job of designing.&nbsp;&nbsp;

00:50:01.920 --> 00:50:05.200
But one approach you can take is just&nbsp;
to do who, what, when, where, why. Well,&nbsp;&nbsp;

00:50:05.200 --> 00:50:07.440
you can just go through those things&nbsp;
and sort of look at everything you're&nbsp;&nbsp;

00:50:07.440 --> 00:50:09.920
deciding to do and say, what&nbsp;
is the who aspect of this?

00:50:09.920 --> 00:50:13.760
What is the, what aspect of it?&nbsp;
This can help you take stuff apart.&nbsp;&nbsp;

00:50:14.560 --> 00:50:20.960
The other thing is to maintain the approach that&nbsp;
says, I don't know, I don't want to know. I once&nbsp;&nbsp;

00:50:20.960 --> 00:50:26.240
said that so often during a C++ course I was&nbsp;
teaching that one of the students made me a shirt.&nbsp;&nbsp;

00:50:27.120 --> 00:50:32.320
It was a Booch diagram. Cause we didn't have,&nbsp;
have a, whatever it is now, the unified one.

00:50:33.280 --> 00:50:34.560
And every line just said that&nbsp;&nbsp;

00:50:35.840 --> 00:50:39.120
that's what you want to do. You really just&nbsp;
don't want to know. All right. So what is,&nbsp;&nbsp;

00:50:39.120 --> 00:50:43.760
what? What is the operations? You know, what,&nbsp;
what is, what is it, what we want to accomplish,&nbsp;&nbsp;

00:50:44.400 --> 00:50:50.240
right. We're going to form abstractions by taking&nbsp;
functions or more particularly sets of functions&nbsp;&nbsp;

00:50:50.240 --> 00:50:55.680
and giving them names. In particular you're going&nbsp;
to use whatever your language lets you use. Right?&nbsp;&nbsp;

00:50:55.680 --> 00:51:02.160
So if you only have interfaces, you'll use&nbsp;
that if you have protocols or type classes,&nbsp;&nbsp;

00:51:02.160 --> 00:51:06.400
you'll use those. So all those things are in&nbsp;
the category. The things you use to make sets&nbsp;&nbsp;

00:51:06.400 --> 00:51:11.120
of functions that are going to be abstractions&nbsp;
and sets of specifications of functions.

00:51:11.920 --> 00:51:15.600
The point I'd like to get across today&nbsp;
is just that they should be really small,&nbsp;&nbsp;

00:51:17.120 --> 00:51:20.640
much smaller than what we typically&nbsp;
see. Java interfaces are huge.&nbsp;&nbsp;

00:51:21.520 --> 00:51:24.640
And the reason why they are huge is just&nbsp;
because Java doesn't have union types. So&nbsp;&nbsp;

00:51:24.640 --> 00:51:30.000
it's inconvenient to say this function takes, you&nbsp;
know, something that does this and that, and that&nbsp;&nbsp;

00:51:30.800 --> 00:51:32.800
you have to make a, this&nbsp;
and that and that interface.

00:51:32.800 --> 00:51:36.720
So we see these giant interfaces. And the thing&nbsp;
with those giant interfaces is that's a lot&nbsp;&nbsp;

00:51:36.720 --> 00:51:42.720
harder to break up those programs. So you're gonna&nbsp;
represent them with your polymorphism constructs,&nbsp;&nbsp;

00:51:42.720 --> 00:51:46.640
they're specifications, right? They're&nbsp;
not actually the implementations.&nbsp;&nbsp;

00:51:47.760 --> 00:51:51.440
They should only use values and other&nbsp;
abstractions in their definitions.

00:51:51.440 --> 00:51:56.480
So you're gonna define interfaces or whatever type&nbsp;
classes that only take interfaces and type classes&nbsp;&nbsp;

00:51:56.480 --> 00:52:02.240
or values and return them. And the biggest problem&nbsp;
you have when you're doing this part of design is&nbsp;&nbsp;

00:52:02.240 --> 00:52:06.800
if you complect this with how. Right. You can&nbsp;
complect it with how by jamming them together&nbsp;&nbsp;

00:52:06.800 --> 00:52:10.960
and saying here's just a concrete function instead&nbsp;
of having an interface or here's a concrete class,&nbsp;&nbsp;

00:52:10.960 --> 00:52:14.560
instead of having an interface, you can&nbsp;
also complect it with how more subtly&nbsp;&nbsp;

00:52:14.560 --> 00:52:18.000
by having some implication of the&nbsp;
semantics of the function dictate how it&nbsp;&nbsp;

00:52:18.800 --> 00:52:21.440
is done. And fold is an example of that.

00:52:25.200 --> 00:52:29.200
Strictly separating what from how is the&nbsp;
key to making how somebody else's problem,&nbsp;&nbsp;

00:52:29.920 --> 00:52:32.080
right? If you've done this really well, you can,&nbsp;&nbsp;

00:52:32.080 --> 00:52:36.240
you can pawn off the work of how on somebody else.&nbsp;
You can say, database engine, you figure out how&nbsp;&nbsp;

00:52:36.240 --> 00:52:40.160
to do this thing or a logic engine, you figure&nbsp;
out how to search for this. I don't need to know.

00:52:41.360 --> 00:52:44.880
Who is about like data or entities. These&nbsp;
are the things that are abstractions are&nbsp;&nbsp;

00:52:44.880 --> 00:52:47.760
going to be connected to eventually,&nbsp;
depending on how your technology works,&nbsp;&nbsp;

00:52:48.560 --> 00:52:53.360
you want to build components up from sub&nbsp;
components in a sort of direct injection style,&nbsp;&nbsp;

00:52:53.360 --> 00:52:55.680
right? You don't want to like&nbsp;
hardwire what the sub-components are.

00:52:55.680 --> 00:53:00.240
You want to as much as possible, take them as&nbsp;
arguments because that's going to give you more&nbsp;&nbsp;

00:53:00.240 --> 00:53:02.320
programmatic flexibility in how you build.&nbsp;&nbsp;

00:53:04.800 --> 00:53:08.560
You should have probably many more sub-components&nbsp;
than you have. So you want really much smaller&nbsp;&nbsp;

00:53:08.560 --> 00:53:12.400
interfaces than you have and more sub-components&nbsp;
than you probably are typically having, because&nbsp;&nbsp;

00:53:12.400 --> 00:53:16.960
usually you have none and then maybe you have one&nbsp;
when you decide, do I need to farm out policy?

00:53:16.960 --> 00:53:20.960
Yes. If you go in saying this is a job and I've&nbsp;
done, who, what, when, where, why? And I found&nbsp;&nbsp;

00:53:20.960 --> 00:53:26.560
five components, don't feel bad. That's&nbsp;
great. You're winning massively by doing that,&nbsp;&nbsp;

00:53:27.280 --> 00:53:32.240
you know, split out policy and stuff like&nbsp;
that. And the thing that you have to be&nbsp;&nbsp;

00:53:32.240 --> 00:53:35.840
aware of when you're building, you know, the&nbsp;
definition of a thing from sub-components&nbsp;&nbsp;

00:53:35.840 --> 00:53:39.440
is any, any of those kinds of, you know,&nbsp;
red, yellow, thinking about blue, blue,&nbsp;&nbsp;

00:53:39.440 --> 00:53:45.360
thinking about yellow, kind of hidden detail&nbsp;
dependencies. So you want to avoid that.

00:53:46.240 --> 00:53:49.280
How things happen. This is the actual&nbsp;
implementation code, the work of,&nbsp;&nbsp;

00:53:49.280 --> 00:53:53.760
of doing the job. You, you strictly&nbsp;
want to connect these things together,&nbsp;&nbsp;

00:53:53.760 --> 00:53:58.320
using those polymorphism constructs. That's the&nbsp;
most powerful thing. Yeah you can use a switch&nbsp;&nbsp;

00:53:58.320 --> 00:54:01.760
statement. You could use pattern matching,&nbsp;
but it's glomming all this stuff together.

00:54:01.760 --> 00:54:08.400
If you use one of these systems, you have an open&nbsp;
polymorphism policy, and that is really powerful,&nbsp;&nbsp;

00:54:08.400 --> 00:54:16.640
especially if it's runtime open, but even if it's&nbsp;
not, it's better than nothing. And again, bewware&nbsp;&nbsp;

00:54:16.640 --> 00:54:21.520
of obstructions that dictate how in some subtle&nbsp;
way, because when you do that, you're really,&nbsp;&nbsp;

00:54:21.520 --> 00:54:25.840
you're nailing the person down the line who has to&nbsp;
do the implementation, you're tying their hands.

00:54:26.400 --> 00:54:30.960
So the more declarative things are the better,&nbsp;
the better things work. And the thing that&nbsp;&nbsp;

00:54:31.680 --> 00:54:35.280
I mean, how is sort of the bottom, right?&nbsp;
Don't mix this up with anything else. All&nbsp;&nbsp;

00:54:35.280 --> 00:54:42.000
these implementations should be islands as much as&nbsp;
possible. When and where, this is pretty simple.&nbsp;&nbsp;

00:54:42.000 --> 00:54:46.320
I think you just have to strenuously,&nbsp;
avoid comparing this with anything.

00:54:47.200 --> 00:54:53.040
I see it accidentally coming in, mostly when&nbsp;
people design systems with directly connected&nbsp;&nbsp;

00:54:53.040 --> 00:54:57.280
objects. Right? So if you know, the, if&nbsp;
your program is architected such that,&nbsp;&nbsp;

00:54:57.280 --> 00:55:01.600
you know, this thing deals with the&nbsp;
input, and then this thing has to do&nbsp;&nbsp;

00:55:01.600 --> 00:55:09.280
the next part of the job. Well, if, if thing&nbsp;
A calls thing B you just complected it, right?

00:55:09.280 --> 00:55:12.000
And now you have a when and where thing, cause now&nbsp;&nbsp;

00:55:12.000 --> 00:55:18.800
A has to know where B is in order to call B.&nbsp;
And when that happens is whenever A, does it&nbsp;&nbsp;

00:55:19.680 --> 00:55:24.800
right? Stick a queue in there, right? Queues are&nbsp;
the way to just get rid of this problem. If you're&nbsp;&nbsp;

00:55:24.800 --> 00:55:30.000
not using queues extensively, you should be, you&nbsp;
should right away, like right after this talk.

00:55:32.400 --> 00:55:35.120
And then this is the why part, this&nbsp;
is sort of the policy and rules.&nbsp;&nbsp;

00:55:35.760 --> 00:55:40.560
This is this is, I think this is hard for&nbsp;
us. We typically put this stuff all over&nbsp;&nbsp;

00:55:40.560 --> 00:55:45.360
our application. And if you ever have to talk&nbsp;
to a customer about what the application does,&nbsp;&nbsp;

00:55:45.360 --> 00:55:48.720
it's really difficult to sit with&nbsp;
them in source code and look at it.

00:55:48.720 --> 00:55:52.480
Now, if you have one of these pretend testing&nbsp;
systems that lets you write English strings&nbsp;&nbsp;

00:55:52.480 --> 00:55:56.800
so the customer can look at that. That's just&nbsp;
silly. Right? You should have code that does&nbsp;&nbsp;

00:55:56.800 --> 00:56:02.080
the work that somebody can look at, which means&nbsp;
to try to, you know put this stuff someplace&nbsp;&nbsp;

00:56:02.080 --> 00:56:06.320
outside, try to find a declarative system or a&nbsp;
rule system which will let you you do this work.

00:56:07.680 --> 00:56:11.840
Finally in this area information, it is simple,&nbsp;&nbsp;

00:56:11.840 --> 00:56:19.200
right? The only thing you can possibly do with&nbsp;
information is ruin it. Right? Don't do it. Right.&nbsp;&nbsp;

00:56:19.200 --> 00:56:23.600
Don't do this stuff. We, I mean, we got it.&nbsp;
Objects, objects just made to like encapsulate&nbsp;&nbsp;

00:56:23.600 --> 00:56:28.160
IO devices. So there's a screen, but I can't like&nbsp;
touch the screen, so I have an object, right?&nbsp;&nbsp;

00:56:28.160 --> 00:56:32.800
There's a mouse. I can't touch the mouse's object.&nbsp;
Right. That's all they're good for. They were&nbsp;&nbsp;

00:56:32.800 --> 00:56:37.280
never supposed be applied to information and we&nbsp;
apply them to information. That's it's just wrong.&nbsp;&nbsp;

00:56:38.160 --> 00:56:43.840
It's wrong. But I can now say it's wrong for a&nbsp;
reason, right? It's wrong. Cause it's complex.&nbsp;&nbsp;

00:56:45.040 --> 00:56:49.440
In particular, it, it ruins your ability&nbsp;
to build generic data manipulation things.

00:56:49.440 --> 00:56:56.480
If you leave data alone, right. You can build&nbsp;
things once that manipulate data and you can&nbsp;&nbsp;

00:56:56.480 --> 00:57:00.560
reuse them all over the place and you know,&nbsp;
they're right once and you're done. Yeah. The&nbsp;&nbsp;

00:57:00.560 --> 00:57:04.960
other thing about it, which also applies to ORM&nbsp;
is that it will tie your logic to representational&nbsp;&nbsp;

00:57:04.960 --> 00:57:10.880
things, which again, tying complexing,&nbsp;
intertwining, so represent data as data.

00:57:10.880 --> 00:57:14.640
Please start using maps and sets&nbsp;
directly. Don't feel like I have&nbsp;&nbsp;

00:57:14.640 --> 00:57:18.160
to write a class now because I have a new&nbsp;
piece of information. That's just silly.

00:57:21.200 --> 00:57:25.120
So the final aspect, right? So&nbsp;
we we've, we choose simple tools.&nbsp;&nbsp;

00:57:25.120 --> 00:57:30.640
We write simple stuff and then sometimes we have&nbsp;
to simplify other people's stuff. In particular,&nbsp;&nbsp;

00:57:30.640 --> 00:57:35.120
we, we may have to simplify the problem&nbsp;
space or some code that somebody else wrote.

00:57:35.840 --> 00:57:38.400
This is a whole separate talk. I'm&nbsp;
not going to get into right now.&nbsp;&nbsp;

00:57:39.040 --> 00:57:43.360
But the job is essentially one of&nbsp;
disentangling. Right. We know what's,&nbsp;&nbsp;

00:57:43.360 --> 00:57:49.280
what's complex. It's entangled. So what do we need&nbsp;
to do? Right. We need to somehow disentangle it.&nbsp;&nbsp;

00:57:49.920 --> 00:57:56.160
Right? You're going to get this. You're going to&nbsp;
need to first sort of figure out where it's going.

00:57:57.120 --> 00:58:02.240
You're going to have to follow stuff around and&nbsp;
eventually label everything. Right? This is the&nbsp;&nbsp;

00:58:02.240 --> 00:58:06.080
start. This is roughly what the process&nbsp;
is like. But again, it's a whole separate&nbsp;&nbsp;

00:58:06.080 --> 00:58:12.080
talk to try to talk about simplification. All&nbsp;
right, I'm going to wrap up a couple of slides.

00:58:13.520 --> 00:58:18.240
The bottom line is simplicity is a choice. It's&nbsp;
your fault if you don't have a simple system.&nbsp;&nbsp;

00:58:19.200 --> 00:58:23.600
And, and I think we have a culture&nbsp;
of complexity, to the extent we all&nbsp;&nbsp;

00:58:23.600 --> 00:58:28.640
continue to use these tools that have complex&nbsp;
outputs. We're just in a rut. We're just&nbsp;&nbsp;

00:58:28.640 --> 00:58:32.160
self-reinforcing. And we have to get&nbsp;
out of that rut. But again, like I said,&nbsp;&nbsp;

00:58:32.160 --> 00:58:35.840
if you're already saying, I know this, I&nbsp;
believe you, I already use something better.

00:58:35.840 --> 00:58:38.800
I've already used that whole right&nbsp;
column then hopefully this talk will&nbsp;&nbsp;

00:58:38.800 --> 00:58:41.280
give you the basis for talking with&nbsp;
somebody else who doesn't believe.&nbsp;&nbsp;

00:58:42.080 --> 00:58:47.040
Right. Talk about simplicity versus&nbsp;
complexity, right? But it is a choice,&nbsp;&nbsp;

00:58:47.680 --> 00:58:52.160
right? It requires constant vigilance. We already&nbsp;
saw the guard rails don't yield simplicity.

00:58:52.160 --> 00:58:57.600
They don't really help us here. Right.&nbsp;
It requires sensibilities and care.&nbsp;&nbsp;

00:58:57.600 --> 00:59:02.480
Your sensibilities about simplicity being equal&nbsp;
to ease of use are wrong. They're just simply&nbsp;&nbsp;

00:59:02.480 --> 00:59:06.240
wrong. Right. We saw the definitions of simple&nbsp;
and easy. They're completely different things,&nbsp;&nbsp;

00:59:07.760 --> 00:59:14.000
right? So easy is not simple. You have to start&nbsp;
developing sensibilities around entanglement.

00:59:14.000 --> 00:59:16.560
That's what you have to just, you&nbsp;
have to have entanglement radar,&nbsp;&nbsp;

00:59:17.120 --> 00:59:20.240
right? You want to look at some software&nbsp;
and say, ah, you know, not that I don't&nbsp;&nbsp;

00:59:20.240 --> 00:59:24.800
like the names you used or the shape of the&nbsp;
code, or there was a semi-colon. I mean,&nbsp;&nbsp;

00:59:24.800 --> 00:59:28.560
that's also important too, but you&nbsp;
want to start seeing complecting.&nbsp;&nbsp;

00:59:28.560 --> 00:59:32.240
You want to start seeing interconnections&nbsp;
between things that could be independent.

00:59:32.240 --> 00:59:36.720
That's where you're going to get the most&nbsp;
power. All the reliability tools you have,&nbsp;&nbsp;

00:59:37.440 --> 00:59:41.040
right. Since they're not about&nbsp;
simplicity, they're all secondary.&nbsp;&nbsp;

00:59:42.240 --> 00:59:45.840
Right. They just do not touch&nbsp;
the core of this problem.&nbsp;&nbsp;

00:59:47.040 --> 00:59:55.280
Right. They're safety nets, but they're nothing&nbsp;
more than that. So how do we make simplicity easy?

00:59:56.480 --> 00:59:59.840
Right. We're going to choose&nbsp;
constructs with simpler&nbsp;&nbsp;

01:00:02.560 --> 01:00:06.560
artifacts, right? And avoid constructs&nbsp;
that have complex artifacts.&nbsp;&nbsp;

01:00:07.520 --> 01:00:12.880
It's the artifacts. It's not the authoring. As&nbsp;
soon as you get in an argument with somebody&nbsp;&nbsp;

01:00:12.880 --> 01:00:17.440
about, oh, we should, we should be using&nbsp;
whatever, get that sorted out, you know,&nbsp;&nbsp;

01:00:17.440 --> 01:00:22.480
because however they feel about the shape of&nbsp;
the code, they type in is independent from this.

01:00:22.480 --> 01:00:23.840
And this is the thing you have to live with.&nbsp;&nbsp;

01:00:25.280 --> 01:00:28.000
We're going to try to create abstractions&nbsp;
that have simplicity as a basis,&nbsp;&nbsp;

01:00:28.880 --> 01:00:35.760
right? We're going to spend a little time up&nbsp;
front simplifying things before we get started&nbsp;&nbsp;

01:00:36.480 --> 01:00:42.160
and recognize that when you simplify things,&nbsp;
you often end up with more things. Right.

01:00:42.160 --> 01:00:47.520
Simplicity is not about counting, right? I'd&nbsp;
have rather have more things hanging nice,&nbsp;&nbsp;

01:00:47.520 --> 01:00:52.800
straight down, not twisted together then&nbsp;
just a couple of things tied in and not.&nbsp;&nbsp;

01:00:53.920 --> 01:00:58.320
And the beautiful thing about making them separate&nbsp;
is you'll have a lot more ability to change it&nbsp;&nbsp;

01:00:58.320 --> 01:01:00.160
which is where I think the benefits lie.

01:01:00.800 --> 01:01:09.120
So I think this is a big deal and I hope&nbsp;
everybody's able to bring it into practice or&nbsp;&nbsp;

01:01:09.120 --> 01:01:15.840
use this as a tool for convincing somebody else&nbsp;
to do that. So I'll leave you with this. This&nbsp;&nbsp;

01:01:15.840 --> 01:01:23.840
is what you say when somebody tries to sell&nbsp;
you a sophisticated type system. Thank you.

